/*
Kiev Group attack Corporation @2009-2024 all rights reserved

if this year is lost, you have no right to leak it online

characteristics:

Hacking UAC

The UAC works when the file controls the machine, but there is an error if the file is launched through the port, it will not do anything

and it can also be installed without the user’s knowledge: “I’m too lazy to write further, sorry )))”

first versions are ready 2024 summer full cyber attack 2025 winter

the software is written in C, C++

*/

#include "bldr.h"
#include "bootefi.h"


#include "efi.h"
#include "efip.h"
#include "flop.h"


//
// Externals
//
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;
extern BOOLEAN GoneVirtual;

#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + \
    (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

    //
// Externals
//
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;

extern BOOLEAN GoneVirtual;

BOOLEAN gInverse = FALSE;


ULONG
BlEfiGetLinesPerRow(
    VOID
    )
/*++

Routine Description:

    Gets the number of lines per EFI console row.

Arguments:

    None.
    
Return Value:

    ULONG - number of lines.

--*/
{
    //
    // TODO: read the modes to determine lines/row.
    //
    // for now we just support 80x25
    //
    
    return 25;
}

ULONG
BlEfiGetColumnsPerLine(
    VOID
    )
/*++

Routine Description:

    Gets the number of columns per EFI console line.

Arguments:

    None.
    
Return Value:

    ULONG - number of columns.

--*/
{
    //
    // TODO: read the modes to determine columns/line.
    //
    // for now we just support 80x25
    //
    return 80;
}


BOOLEAN
BlEfiClearDisplay(
    VOID
    )
/*++

Routine Description:

    Clears the display.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    EFI_STATUS Status;

    //
    // you must be in physical mode to call EFI
    //
    FlipToPhysical();
    Status = EfiST->ConOut->ClearScreen(EfiST->ConOut);
    FlipToVirtual();

    return (Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiClearToEndOfDisplay(
    VOID
    )
/*++

Routine Description:

    Clears from the current cursor position to the end of the display.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    ULONG i,j, LinesPerRow,ColumnsPerLine;
    BOOLEAN FirstTime = TRUE;

    //
    // you must be in physical mode to call EFI
    //
    FlipToPhysical();

    LinesPerRow = BlEfiGetLinesPerRow();
    ColumnsPerLine = BlEfiGetColumnsPerLine();


    for (i = EfiST->ConOut->Mode->CursorRow; i<= LinesPerRow; i++) {

        j = FirstTime 
             ? EfiST->ConOut->Mode->CursorColumn
             : 0 ;

        FirstTime = FALSE;
        
        for (; j <= ColumnsPerLine; j++) {

            EfiST->ConOut->SetCursorPosition(
                                EfiST->ConOut,
                                i,
                                j);
    
            //
            // outputting a space should clear the current character
            //
            
            EfiST->ConOut->OutputString( EfiST->ConOut,
                                         L" " );
        }

    }

    //
    // flip back into virtual mode and return
    //
    FlipToVirtual();

    return(TRUE);
}


BOOLEAN
BlEfiClearToEndOfLine(
    VOID
    )
/*++

Routine Description:

    Clears from the current cursor position to the end of the line.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    ULONG i, ColumnsPerLine;
    ULONG x, y;

    ColumnsPerLine = BlEfiGetColumnsPerLine();

    //
    // save current cursor position
    //
    BlEfiGetCursorPosition( &x, &y );
    
    FlipToPhysical();
    for (i = EfiST->ConOut->Mode->CursorColumn; i <= ColumnsPerLine; i++) {
        
        EfiST->ConOut->SetCursorPosition(
                            EfiST->ConOut,
                            i,
                            EfiST->ConOut->Mode->CursorRow);
        
        //
        // outputting a space should clear the current character
        //
        EfiST->ConOut->OutputString( EfiST->ConOut,
                                     L" " );
    }

    //
    // restore the current cursor position
    //
    EfiST->ConOut->SetCursorPosition(
                            EfiST->ConOut,
                            x,
                            y );

    FlipToVirtual();

    return(TRUE);
}


BOOLEAN
BlEfiGetCursorPosition(
    OUT PULONG x, OPTIONAL
    OUT PULONG y OPTIONAL
    )
/*++

Routine Description:

    retrieves the current cursor position

Arguments:

    x - if specified, receives the current cursor column.
    y - if specified, receives the current cursor row.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    FlipToPhysical();

    if (x) {
        *x = EfiST->ConOut->Mode->CursorColumn;
    }

    if (y) {
        *y = EfiST->ConOut->Mode->CursorRow;
    }
        
    FlipToVirtual();

    return(TRUE);

}


BOOLEAN
BlEfiPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )
/*++

Routine Description:

    Sets the current cursor position.

Arguments:

    Column - column to set (x coordinate)
    Row - row to set (y coordinate)
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;

    FlipToPhysical();
    Status = EfiST->ConOut->SetCursorPosition(EfiST->ConOut,Column,Row);
    FlipToVirtual();

    return (Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiEnableCursor(
    BOOLEAN bVisible
    )
/*++

Routine Description:

    Turns on or off the input cursor.

Arguments:

    bVisible - TRUE indicates that the cursor should be made visible.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    EFI_STATUS Status;

    FlipToPhysical();
    Status = EfiST->ConOut->EnableCursor( EfiST->ConOut, bVisible );
    FlipToVirtual();

    return (Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiSetAttribute(
    ULONG Attribute
    )
/*++

Routine Description:

    Sets the current attribute for the console.
    
    This routines switches between the ATT_* constants into the EFI_* display
    constants.  Not all of the ATT_ flags can be supported under EFI, so we 
    make a best guess.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;
    UINTN foreground,background;
    UINTN EfiAttribute;

    switch (Attribute & 0xf) {
        case ATT_FG_BLACK:
            foreground = EFI_BLACK;
            break;
        case ATT_FG_RED:
            foreground = EFI_RED;
            break;
        case ATT_FG_GREEN:
            foreground = EFI_GREEN;
            break;
        case ATT_FG_YELLOW:
            foreground = EFI_YELLOW;
            break;
        case ATT_FG_BLUE:
            foreground = EFI_BLUE;
            break;
        case ATT_FG_MAGENTA:
            foreground = EFI_MAGENTA;
            break;
        case ATT_FG_CYAN:
            foreground = EFI_CYAN;
            break;
        case ATT_FG_WHITE:
            foreground = EFI_LIGHTGRAY; // this is a best guess
            break;
        case ATT_FG_INTENSE:
            foreground = EFI_WHITE; // this is a best guess
            break;
        default:
            // you may fall into this for blinking attribute, etc.
            foreground = EFI_WHITE;  
    }

    switch ( Attribute & ( 0xf << 4)) {
        case ATT_BG_BLACK:
            background = EFI_BACKGROUND_BLACK;
            break;
        case ATT_BG_RED:
            background = EFI_BACKGROUND_RED;
            break;
        case ATT_BG_GREEN:
            background = EFI_BACKGROUND_GREEN;
            break;
        case ATT_BG_YELLOW:
            // there is no yellow background in EFI
            background = EFI_BACKGROUND_CYAN;
            break;
        case ATT_BG_BLUE:
            background = EFI_BACKGROUND_BLUE;
            break;
        case ATT_BG_MAGENTA:
            background = EFI_BACKGROUND_MAGENTA;
            break;
        case ATT_BG_CYAN:
            background = EFI_BACKGROUND_CYAN;
            break;
        case ATT_BG_WHITE:
            // there is no white background in EFI
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
        case ATT_BG_INTENSE:
            // there is no intense (or white) background in EFI
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
        default:
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
    }
        
    EfiAttribute = foreground | background ;
    

    FlipToPhysical();
    Status = EfiST->ConOut->SetAttribute(EfiST->ConOut,EfiAttribute);
    FlipToVirtual();

    return (Status == EFI_SUCCESS);
}


BOOLEAN
BlEfiSetInverseMode(
    BOOLEAN fInverseOn
    )
/*++

Routine Description:

    Sets the console text to an inverse attribute.
    
    Since EFI doesn't support the concept of inverse, we have
    to make a best guess at this.  Note that if you clear the
    display, etc., then the entire display will be set to this
    attribute.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;
    UINTN EfiAttribute,foreground,background;

    //
    // if it's already on, then just return.
    //
    if (fInverseOn && gInverse) {
        return(TRUE);
    }

    //
    // if it's already off, then just return.
    //
    if (!fInverseOn && !gInverse) {
        return(TRUE);
    }


    FlipToPhysical();

    //
    // get the current attribute and switch it.
    //
    EfiAttribute = EfiST->ConOut->Mode->Attribute;
    foreground = EfiAttribute & 0xf;
    background = (EfiAttribute & 0xf0) >> 4 ;

    EfiAttribute =  background | foreground;

    Status = EfiST->ConOut->SetAttribute(EfiST->ConOut,EfiAttribute);
    FlipToVirtual();

    gInverse = !gInverse;

    return (Status == EFI_SUCCESS);
}




//
// Array of EFI drawing characters.
//
// This array MUST MATCH the GraphicsChar enumerated type in bldr.h.
//
USHORT EfiDrawingArray[GraphicsCharMax] = { 
    BOXDRAW_DOUBLE_DOWN_RIGHT,
    BOXDRAW_DOUBLE_DOWN_LEFT,
    BOXDRAW_DOUBLE_UP_RIGHT,
    BOXDRAW_DOUBLE_UP_LEFT,
    BOXDRAW_DOUBLE_VERTICAL,
    BOXDRAW_DOUBLE_HORIZONTAL,
    BLOCKELEMENT_FULL_BLOCK,
    BLOCKELEMENT_LIGHT_SHADE    
};



USHORT
BlEfiGetGraphicsChar(
    IN GraphicsChar WhichOne
    )
/*++

Routine Description:

    Gets the appropriate mapping character.
    
    
    
Arguments:

    GraphicsChar - enumerated type indicating character to be retrieved.
    
Return Value:

    USHORT - EFI drawing character.

--*/
{
    //
    // just return a space if the input it out of range
    //
    if (WhichOne >= GraphicsCharMax) {
        return(L' ');
    }
    
    return(EfiDrawingArray[WhichOne]);
}


#if DBG

VOID
DBG_EFI_PAUSE(
    VOID
    )
{
    EFI_EVENT EventArray[2];
    EFI_INPUT_KEY Key;
    UINTN num;

    if (GoneVirtual) {
        FlipToPhysical();
    }
    EventArray[0] = EfiST->ConIn->WaitForKey;
    EventArray[1] = NULL;
    EfiBS->WaitForEvent(1,EventArray,&num);
    //
    // reset the event
    //
    EfiST->ConIn->ReadKeyStroke( EfiST->ConIn, &Key );
    if (GoneVirtual) {
        FlipToVirtual();
    }
    
}

#else

VOID
DBG_EFI_PAUSE(
    VOID
    )
{
    NOTHING;
}

#endif

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#include <efiboot.h>

ARC_STATUS
BlpGetPartitionFromDevicePath (
    IN EFI_DEVICE_PATH UNALIGNED *DevicePath,
    IN PUCHAR MaximumValidAddress,
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber,
    OUT HARDDRIVE_DEVICE_PATH UNALIGNED **HarddriveDevicePath,
    OUT FILEPATH_DEVICE_PATH UNALIGNED **FilepathDevicePath
    );

//
// Externals
//

extern VOID FlipToVirtual();
extern VOID FlipToPhysical();
extern ULONGLONG CompareGuid();

extern BOOT_CONTEXT BootContext;
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;

EFI_STATUS
EfiGetVariable (
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    OUT UINT32 *Attributes OPTIONAL,
    IN OUT UINTN *DataSize,
    OUT VOID *Data
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->GetVariable(
                                        VariableName,
                                        VendorGuid,
                                        Attributes,
                                        DataSize,
                                        Data
                                        );

    FlipToVirtual();
    
    return status;

} // EfiGetVariable
    
EFI_STATUS
EfiSetVariable (
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    IN UINT32 Attributes,
    IN UINTN DataSize,
    IN VOID *Data
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->SetVariable(
                                        VariableName,
                                        VendorGuid,
                                        Attributes,
                                        DataSize,
                                        Data
                                        );

    FlipToVirtual();
    
    return status;

} // EfiSetVariable
    
EFI_STATUS
EfiGetNextVariableName (
    IN OUT UINTN *VariableNameSize,
    IN OUT CHAR16 *VariableName,
    IN OUT EFI_GUID *VendorGuid
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->GetNextVariableName(
                                        VariableNameSize,
                                        VariableName,
                                        VendorGuid
                                        );

    FlipToVirtual();
    
    return status;

} // EfiGetNextVariableName
    
LONG
SafeStrlen (
    PUCHAR String,
    PUCHAR Max
    )
{
    PUCHAR p = String;
    while ( (p < Max) && (*p != 0) ) {
        p++;
    }

    if ( p < Max ) {
        return (LONG)(p - String);
    }

    return -1;

} // SafeStrlen

LONG
SafeWcslen (
    PWCHAR String,
    PWCHAR Max
    )
{
    PWCHAR p = String;
    while ( (p < Max) && (*p != 0) ) {
        p++;
    }

    if ( p < Max ) {
        return (LONG)(p - String);
    }

    return -1;

} // SafeWclen

ARC_STATUS
BlGetEfiBootOptions (
    OUT PUCHAR Argv0String OPTIONAL,
    OUT PUCHAR SystemPartition OPTIONAL,
    OUT PUCHAR OsLoaderFilename OPTIONAL,
    OUT PUCHAR OsLoadPartition OPTIONAL,
    OUT PUCHAR OsLoadFilename OPTIONAL,
    OUT PUCHAR FullKernelPath OPTIONAL,
    OUT PUCHAR OsLoadOptions OPTIONAL
    )
{
    EFI_STATUS status;
    ARC_STATUS arcStatus;
    EFI_GUID EfiGlobalVariable = EFI_GLOBAL_VARIABLE;
    UCHAR variable[512];
    UCHAR syspart[100];
    UCHAR loader[100];
    UCHAR loadpart[100];
    UCHAR loadname[100];
    PEFI_LOAD_OPTION efiLoadOption;
    EFI_DEVICE_PATH UNALIGNED *devicePath;
    HARDDRIVE_DEVICE_PATH UNALIGNED *harddriveDp;
    FILEPATH_DEVICE_PATH UNALIGNED *filepathDp;
    WINDOWS_OS_OPTIONS UNALIGNED *osOptions;
    UINT16 bootCurrent;
    UINTN length;
    PUCHAR max;
    PUCHAR osloadpart;
    PUCHAR osloadname;
    PUCHAR osloadoptions;
    LONG l;
    BOOLEAN end;
    WCHAR UNALIGNED *fp;
    ULONG bootDisk;
    ULONG bootPartition;
    ULONG loadDisk;
    ULONG loadPartition;
    LONG i;
    PFILE_PATH loadFilePath;
    PWCHAR wideosloadoptions;
    WCHAR currentBootEntryName[9];

    //
    // Get the ordinal of the entry that was used to boot the system.
    //
    length = sizeof(bootCurrent);
    status = EfiGetVariable( L"BootCurrent", &EfiGlobalVariable, NULL, &length, &bootCurrent );
    if ( status != EFI_SUCCESS ) {
        return ENOENT;
    }

    //
    // Read the boot entry.
    //

    swprintf( currentBootEntryName, L"Boot%04x", bootCurrent );
    length = 512;
    status = EfiGetVariable( currentBootEntryName, &EfiGlobalVariable, NULL, &length, variable );
    if ( status != EFI_SUCCESS ) {
        return ENOENT;
    }

    //
    // Verify the boot entry.
    //

    max = variable + length;

    //
    // Is it long enough even to contain the base part of the EFI load option?
    //

    if ( length < sizeof(EFI_LOAD_OPTION) ) {
        return ENOENT;
    }

    //
    // Is the description properly terminated?
    //

    efiLoadOption = (PEFI_LOAD_OPTION)variable;
    l = SafeWcslen( efiLoadOption->Description, (PWCHAR)max );
    if ( l < 0 ) {
        return ENOENT;
    }

    devicePath = (EFI_DEVICE_PATH *)((PUCHAR)efiLoadOption +
                    FIELD_OFFSET(EFI_LOAD_OPTION,Description) +
                    ((l + 1) * sizeof(CHAR16)));
    osOptions = (WINDOWS_OS_OPTIONS UNALIGNED *)((PUCHAR)devicePath + efiLoadOption->FilePathLength);

    length -= (UINTN)((PUCHAR)osOptions - variable);

    //
    // Does the OsOptions structure look like a WINDOWS_OS_OPTIONS structure?
    //

    if ( (length < FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) ||
         (length != osOptions->Length) ||
         (WINDOWS_OS_OPTIONS_VERSION != osOptions->Version) ||
         (strcmp(osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) != 0) ) {
        return ENOENT;
    }

    //
    // Is the OsLoadOptions string properly terminated?
    //

    wideosloadoptions = (PWCHAR)osOptions->OsLoadOptions;
    l = SafeWcslen( wideosloadoptions, (PWCHAR)max );
    if ( l < 0 ) {
        return ENOENT;
    }

    //
    // Convert the OsLoadOptions string to ANSI.
    //

    osloadoptions = (PUCHAR)wideosloadoptions;
    for ( i = 1; i <= l; i++ ) {
        osloadoptions[i] = (UCHAR)wideosloadoptions[i];
    }
    
    //
    // Parse the device path to determine the OS load partition and directory.
    // Convert the directory name to ANSI.
    //

    loadFilePath = ADD_OFFSET( osOptions, OsLoadPathOffset );

#if 0
    //
    // turn this on to see the device path to the loader executable and device
    // path to the operating system
    //
    BlPrint(TEXT("Device Path = %s\r\n"), DevicePathToStr( devicePath ));
    BlPrint(TEXT("Embedded Device Path to OS = %s\r\n"), DevicePathToStr( (EFI_DEVICE_PATH UNALIGNED *)loadFilePath->FilePath ));
    DBG_EFI_PAUSE();
#endif
    arcStatus = BlpGetPartitionFromDevicePath(
                    (EFI_DEVICE_PATH UNALIGNED *)loadFilePath->FilePath,
                    max,
                    &loadDisk,
                    &loadPartition,
                    &harddriveDp,
                    &filepathDp
                    );
    if (arcStatus != ESUCCESS) {
        return arcStatus;
    }
    sprintf( loadpart,
             "multi(0)disk(0)rdisk(%d)partition(%d)",
             loadDisk,
             loadPartition );
    fp = filepathDp->PathName;
    l = 0;
    while ( (l < (99 - 9 - strlen(loadpart))) &&
            ((PUCHAR)fp < max) &&
            (*fp != 0) ) {
        loadname[l++] = (UCHAR)*fp++;
    }
    loadname[l] = 0;

    //
    // Translate loader device path to partition/path.
    //

    arcStatus = BlpGetPartitionFromDevicePath(
                    devicePath,
                    max,
                    &bootDisk,
                    &bootPartition,
                    &harddriveDp,
                    &filepathDp
                    );
    if (arcStatus != ESUCCESS) {
        return arcStatus;
    }

    //
    // Form the ARC name for the partition.
    //

    sprintf( syspart,
             "multi(0)disk(0)rdisk(%d)partition(%d)",
             bootDisk,
             bootPartition );

    //
    // Extract the path to the loader.
    //

    fp = filepathDp->PathName;
    l = 0;

    while ( (l < (99 - 9 - strlen(syspart))) &&
            ((PUCHAR)fp < max) &&
            (*fp != 0) ) {
        loader[l++] = (UCHAR)*fp++;
    }
    loader[l] = 0;

    //
    // Create the strings that the loader needs.
    //

    if ( Argv0String != NULL ) {
        sprintf( Argv0String, "%s%s", syspart, loader );
    }
    if ( OsLoaderFilename != NULL ) {
        sprintf( OsLoaderFilename, "OSLOADER=%s%s", syspart, loader );
    }
    if ( SystemPartition != NULL ) {
        sprintf( SystemPartition, "SYSTEMPARTITION=%s", syspart );
    }
    if ( OsLoadOptions != NULL ) {
        sprintf( OsLoadOptions, "OSLOADOPTIONS=%s", osloadoptions );
    }
    if ( OsLoadFilename != NULL ) {
        sprintf( OsLoadFilename, "OSLOADFILENAME=%s", loadname );
    }
    if ( FullKernelPath != NULL ) {
        sprintf( FullKernelPath, "%s%s", loadpart, loadname );
    }
    if ( OsLoadPartition != NULL ) {
        sprintf( OsLoadPartition, "OSLOADPARTITION=%s", loadpart );
    }

    return ESUCCESS;

} // BlGetEfiBootOptions

ARC_STATUS
BlpGetPartitionFromDevicePath (
    IN EFI_DEVICE_PATH UNALIGNED *DevicePath,
    IN PUCHAR MaximumValidAddress,
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber,
    OUT HARDDRIVE_DEVICE_PATH UNALIGNED **HarddriveDevicePath,
    OUT FILEPATH_DEVICE_PATH UNALIGNED **FilepathDevicePath
    )
{
    ARC_STATUS status;
    EFI_DEVICE_PATH UNALIGNED *devicePath;
    HARDDRIVE_DEVICE_PATH UNALIGNED *harddriveDp;
    FILEPATH_DEVICE_PATH UNALIGNED *filepathDp;
    LOGICAL end;
    ULONG disk;
    ULONG partition;

    //
    // Find the MEDIA/HARDDRIVE and MEDIA/FILEPATH elements in the device path.
    //

    devicePath = DevicePath;
    harddriveDp = NULL;
    filepathDp = NULL;
    end = FALSE;

    while ( ((PUCHAR)devicePath < MaximumValidAddress) &&
            !end &&
            ((harddriveDp == NULL) || (filepathDp == NULL)) ) {

        switch( devicePath->Type ) {
        
        case END_DEVICE_PATH_TYPE:
            end = TRUE;
            break;

        case MEDIA_DEVICE_PATH:
            switch ( devicePath->SubType ) {
            
            case MEDIA_HARDDRIVE_DP:
                harddriveDp = (HARDDRIVE_DEVICE_PATH UNALIGNED *)devicePath;
                break;

            case MEDIA_FILEPATH_DP:
                filepathDp = (FILEPATH_DEVICE_PATH UNALIGNED *)devicePath;
                break;

            default:
                break;
            }

        default:
            break;
        }

        devicePath = (EFI_DEVICE_PATH UNALIGNED *)NextDevicePathNode( devicePath );
    }

    //
    // If the two necessary elements weren't found, we can't continue.
    //

    if ( (harddriveDp == NULL) || (filepathDp == NULL) ) {
        return ENOENT;
    }

    //
    // Determine the disk number of the disk by opening the given partition
    // number on each disk and checking the partition signature.
    //

    partition = harddriveDp->PartitionNumber;

    disk = 0;
    while ( TRUE ) {
        EFI_PARTITION_ENTRY UNALIGNED *partEntry;
        status = BlGetGPTDiskPartitionEntry( disk, (UCHAR)partition, &partEntry );
        if ( status == EINVAL ) {
            return ENOENT;
        }
        if ( status == ESUCCESS ) {
            if ( memcmp(partEntry->Id, harddriveDp->Signature, 16) == 0 ) {
                break;
            }
        }
        disk++;
    }

    //
    // Return information about this disk, and about the device path.
    //

    *DiskNumber = disk;
    *PartitionNumber = partition;
    *HarddriveDevicePath = harddriveDp;
    *FilepathDevicePath = filepathDp;

    return ESUCCESS;

} // BlpGetPartitionFromDevicePath

#if defined (_IA64_)
#include "bootia64.h"
#endif

#if defined (_X86_)
#include "bldrx86.h"
#endif

#include "displayp.h"
#include "stdio.h"

#include "efi.h"
#include "efip.h"
#include "flop.h"

#include "bootefi.h"

//
// Externals
//
extern BOOT_CONTEXT BootContext;
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;

//
// Takes any pending input and converts it into a KEY value.  Non-blocking, returning 0 if no input available.
//
ULONG
BlGetKey()
{
    ULONG Key = 0;
    UCHAR Ch;
    ULONG Count;

    if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

        ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

        if (Ch == ASCI_CSI_IN) {

            if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

                ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

                //
                // All the function keys start with ESC-O
                //
                switch (Ch) {
                case 'O':

                    ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);  // will not or block, as the buffer is already filled

                    switch (Ch) {
                    case 'P': 
                        Key = F1_KEY;
                        break;

                    case 'Q': 
                        Key = F2_KEY;
                        break;

                    case 'w': 
                        Key = F3_KEY;
                        break;

                    case 't': 
                        Key = F5_KEY;
                        break;

                    case 'u': 
                        Key = F6_KEY;
                        break;

                    case 'r': 
                        Key = F8_KEY;
                        break;

                    case 'M':
                        Key = F10_KEY;
                        break;
                    }
                    break;

                case 'A':
                    Key = UP_ARROW;
                    break;

                case 'B':
                    Key = DOWN_ARROW;
                    break;

                case 'C':
                    Key = RIGHT_KEY;
                    break;

                case 'D':
                    Key = LEFT_KEY;
                    break;

                case 'H':
                    Key = HOME_KEY;
                    break;

                case 'K':
                    Key = END_KEY;
                    break;

                case '@':
                    Key = INS_KEY;
                    break;

                case 'P':
                    Key = DEL_KEY;
                    break;

                case TAB_KEY:
                    Key = BACKTAB_KEY;
                    break;

                }

            } else { // Single escape key, as no input is waiting.

                Key = ESCAPE_KEY;

            }

        } else if (Ch == 0x8) {

            Key = BKSP_KEY;

        } else {

            Key = (ULONG)Ch;

        }

    }

    return Key;
}


VOID
BlInputString(
    IN ULONG    Prompt,
    IN ULONG    CursorX,
    IN ULONG    PosY,
    IN PUCHAR   String,
    IN ULONG    MaxLength
    )
{
    PTCHAR      PromptString;
    ULONG       TextX, TextY;
    ULONG       Length, Index;
    _TUCHAR     CursorChar[2];
    ULONG       Key;
    _PTUCHAR    p;
    ULONG       i;
    ULONG       Count;
    _PTUCHAR    pString;
#ifdef UNICODE
    WCHAR       StringW[200];
    UNICODE_STRING uString;
    ANSI_STRING aString;
    pString = StringW;
    uString.Buffer = StringW;
    uString.MaximumLength = sizeof(StringW);
    RtlInitAnsiString(&aString, String );
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#else
    pString = String;
#endif    


    PromptString = BlFindMessage(Prompt);
    Length = strlen(String);
    CursorChar[1] = TEXT('\0');

    //
    // Print prompt
    //

    BlEfiPositionCursor( PosY, CursorX );
    BlEfiEnableCursor( TRUE );
    ArcWrite(BlConsoleOutDeviceId, PromptString, _tcslen(PromptString)*sizeof(TCHAR), &Count);

    //
    // Indent cursor to right of prompt
    //

    CursorX += _tcslen(PromptString);
    TextX = CursorX;
    Key = 0;

    for (; ;) {

        TextY = TextX + Length;
        if (CursorX > TextY) {
            CursorX = TextY;
        }
        if (CursorX < TextX) {
            CursorX = TextX;
        }

        Index = CursorX - TextX;
        pString[Length] = 0;

        //
        // Display current string
        //

        BlEfiPositionCursor( TextY, TextX );
        ArcWrite(
            BlConsoleOutDeviceId, 
            pString, 
            _tcslen(pString)*sizeof(TCHAR), 
            &Count);
        ArcWrite(BlConsoleOutDeviceId, TEXT("  "), sizeof(TEXT("  ")), &Count);
        if (Key == 0x0d) {      // enter key?
            break ;
        }

        //
        // Display cursor
        //
        BlEfiPositionCursor( PosY, CursorX );
        BlEfiSetInverseMode( TRUE );
        CursorChar[0] = pString[Index] ? pString[Index] : TEXT(' ');
        ArcWrite(BlConsoleOutDeviceId, CursorChar, sizeof(_TUCHAR), &Count);
        BlEfiSetInverseMode( FALSE );
        BlEfiPositionCursor( PosY, CursorX );
        BlEfiEnableCursor(TRUE);
        
        //
        // Get key and process it
        //

        while (!(Key = BlGetKey())) ;

        switch (Key) {
            case HOME_KEY:
                CursorX = TextX;
                break;

            case END_KEY:
                CursorX = TextY;
                break;

            case LEFT_KEY:
                CursorX -= 1;
                break;

            case RIGHT_KEY:
                CursorX += 1;
                break;

            case BKSP_KEY:
                if (!Index) {
                    break;
                }

                CursorX -= 1;
                pString[Index-1] = CursorChar[0];
                // fallthough to DEL_KEY
            case DEL_KEY:
                if (Length) {
                    p = pString+Index;
                    i = Length-Index+1;
                    while (i) {
                        p[0] = p[1];
                        p += 1;
                        i -= 1;
                    }
                    Length -= 1;
                }
                break;

            case INS_KEY:
                if (Length < MaxLength) {
                    p = pString+Length;
                    i = Length-Index+1;
                    while (i) {
                        p[1] = p[0];
                        p -= 1;
                        i -= 1;
                    }
                    pString[Index] = TEXT(' ');
                    Length += 1;
                }
                break;

            default:
                Key = Key & 0xff;

                if (Key >= ' '  &&  Key <= 'z') {
                    if (CursorX == TextY  &&  Length < MaxLength) {
                        Length += 1;
                    }

                    pString[Index] = (_TUCHAR)Key;
                    pString[MaxLength] = 0;
                    CursorX += 1;
                }
                break;

                extern EFI_SYSTEM_TABLE        *EfiST;
#define DBG_TRACE(_X) EfiST->ConOut->OutputString(EfiST->ConOut, (_X))

#else

#define DBG_TRACE(_X) 

#endif // for FORCE_CD_BOOT




//
// Headless boot defines
//
ULONG BlTerminalDeviceId = 0;
BOOLEAN BlTerminalConnected = FALSE;
ULONG   BlTerminalDelay = 0;

HEADLESS_LOADER_BLOCK LoaderRedirectionInformation;

//
// Define COM Port registers.
//
#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

//
// Define Serial IO Protocol
//
EFI_GUID EfiSerialIoProtocol = SERIAL_IO_PROTOCOL;
SERIAL_IO_INTERFACE *SerialIoInterface;

//
// Define debugger port initial state.
//
typedef struct _CPPORT {
    PUCHAR Address;
    ULONG Baud;
    USHORT Flags;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default
#define PORT_MODEMCONTROL   0x0002      // using modem controls

CPPORT Port[4] = {
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE}
                 };



//
// This is how we find table information from
// the ACPI table index.
//
extern PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );



LOGICAL
BlRetrieveBIOSRedirectionInformation(
    VOID
    )

/*++

Routine Description:

    This functions retrieves the COM port information from the ACPI
    table.

Arguments:

    We'll be filling in the LoaderRedirectionInformation structure.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PDEBUG_PORT_TABLE   pPortTable = NULL;
    LOGICAL             ReturnValue = FALSE;
    LOGICAL             FoundIt = FALSE;
    EFI_DEVICE_PATH     *DevicePath = NULL;
    EFI_DEVICE_PATH     *RootDevicePath = NULL;
    EFI_DEVICE_PATH     *StartOfDevicePath = NULL;
    EFI_STATUS          Status = EFI_UNSUPPORTED;
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    UART_DEVICE_PATH    *UartDevicePath;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    UINTN               reqd;
    EFI_GUID EfiGlobalVariable  = EFI_GLOBAL_VARIABLE;
    PUCHAR              CurrentAddress = NULL;
    UCHAR               Checksum;
    ULONG               i;
    ULONG               CheckLength;



    pPortTable = (PDEBUG_PORT_TABLE)BlFindACPITable( "SPCR",
                                                     sizeof(DEBUG_PORT_TABLE) );

    if( pPortTable ) {

        //
        // generate a checksum for later validation.
        //
        CurrentAddress = (PUCHAR)pPortTable;
        CheckLength = pPortTable->Header.Length;
        Checksum = 0;
        for( i = 0; i < CheckLength; i++ ) {
            Checksum += CurrentAddress[i];
        }


        if(
                                                // checksum is okay?
            (Checksum == 0) &&

                                                // device address defined?
            ((UCHAR UNALIGNED *)pPortTable->BaseAddress.Address.QuadPart != (UCHAR *)NULL) &&

                                                // he better be in system or memory I/O
                                                // note: 0 - systemI/O
                                                //       1 - memory mapped I/O
            ((pPortTable->BaseAddress.AddressSpaceID == 0) ||
             (pPortTable->BaseAddress.AddressSpaceID == 1))

         ) {


            if( pPortTable->BaseAddress.AddressSpaceID == 0 ) {
                LoaderRedirectionInformation.IsMMIODevice = TRUE;
            } else {
                LoaderRedirectionInformation.IsMMIODevice = FALSE;
            }


            //
            // We got the table.  Now dig out the information we want.
            // See definitiion of DEBUG_PORT_TABLE (acpitabl.h)
            //
            LoaderRedirectionInformation.UsedBiosSettings = TRUE;
            LoaderRedirectionInformation.PortNumber = 3;
            LoaderRedirectionInformation.PortAddress = (UCHAR UNALIGNED *)(pPortTable->BaseAddress.Address.QuadPart);

            if( pPortTable->BaudRate == 7 ) {
                LoaderRedirectionInformation.BaudRate = BD_115200;
            } else if( pPortTable->BaudRate == 6 ) {
                LoaderRedirectionInformation.BaudRate = BD_57600;
            } else if( pPortTable->BaudRate == 4 ) {
                LoaderRedirectionInformation.BaudRate = BD_19200;
            } else {
                LoaderRedirectionInformation.BaudRate = BD_9600;
            }

            LoaderRedirectionInformation.Parity = pPortTable->Parity;
            LoaderRedirectionInformation.StopBits = pPortTable->StopBits;
            LoaderRedirectionInformation.TerminalType = pPortTable->TerminalType;

            
            //
            // If this is a new DEBUG_PORT_TABLE, then it's got the PCI device
            // information.
            //
            if( pPortTable->Header.Length >= sizeof(DEBUG_PORT_TABLE) ) {

                LoaderRedirectionInformation.PciDeviceId = *((USHORT UNALIGNED *)(&pPortTable->PciDeviceId));
                LoaderRedirectionInformation.PciVendorId = *((USHORT UNALIGNED *)(&pPortTable->PciVendorId));
                LoaderRedirectionInformation.PciBusNumber = (UCHAR)pPortTable->PciBusNumber;
                LoaderRedirectionInformation.PciSlotNumber = (UCHAR)pPortTable->PciSlotNumber;
                LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)pPortTable->PciFunctionNumber;
                LoaderRedirectionInformation.PciFlags = *((ULONG UNALIGNED *)(&pPortTable->PciFlags));
            } else {

                //
                // There's no PCI device information in this table.
                //
                LoaderRedirectionInformation.PciDeviceId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciVendorId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciBusNumber = 0;
                LoaderRedirectionInformation.PciSlotNumber = 0;
                LoaderRedirectionInformation.PciFunctionNumber = 0;
                LoaderRedirectionInformation.PciFlags = 0;
            }

            return TRUE;

        }

    }


    //
    // We didn't get anything from the ACPI table.  Look
    // for the ConsoleOutHandle and see if someone configured
    // the EFI firmware to redirect.  If so, we can pickup
    // those settings and carry them forward.
    //


    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: didn't find SPCR table\r\n");


    FoundIt = FALSE;
    //
    // Get the CONSOLE Device Paths.
    //
    
    reqd = 0;
    Status = EfiST->RuntimeServices->GetVariable(
                                        L"ConOut",
                                        &EfiGlobalVariable,
                                        NULL,
                                        &reqd,
                                        NULL );

    if( Status == EFI_BUFFER_TOO_SMALL ) {

        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: GetVariable(ConOut) success\r\n");


#ifndef  DONT_USE_EFI_MEMORY
        Status = EfiBS->AllocatePool(
                            EfiLoaderData,
                            reqd,
                            (VOID **) &StartOfDevicePath);
        if( Status != EFI_SUCCESS ) {
            WCHAR DebugBuffer[120];
            wsprintf( DebugBuffer, L"BlRetreiveBIOSRedirectionInformation: AllocatePool returned (%x)\r\n", Status );
            DBG_TRACE( DebugBuffer );
            StartOfDevicePath = NULL;
        }

#else
        //
        // go back to virtual mode to allocate some memory
        //
        FlipToVirtual();
        StartOfDevicePath = BlAllocateHeapAligned( (ULONG)reqd );

        if( StartOfDevicePath ) {
            //
            // convert the address into a physical address
            //
            StartOfDevicePath = (EFI_DEVICE_PATH *) ((ULONGLONG)StartOfDevicePath & ~KSEG0_BASE);
        }

        //
        // go back into physical mode
        // 
        FlipToPhysical();
#endif

        if (StartOfDevicePath) {
            
            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: allocated pool for variable\r\n");

            Status = EfiST->RuntimeServices->GetVariable(
                                                        L"ConOut",
                                                        &EfiGlobalVariable,
                                                        NULL,
                                                        &reqd,
                                                        (VOID *)StartOfDevicePath);

            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: GetVariable returned\r\n");

        } else {
            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: Failed to allocate memory for CONOUT variable.\r\n");
        }
    } else {
        WCHAR DebugBuffer[120];
        wsprintf( DebugBuffer, L"BlRetreiveBIOSRedirectionInformation: GetVariable returned (%x)\r\n", Status );
        DBG_TRACE( DebugBuffer );
        Status = EFI_BAD_BUFFER_SIZE;
    }



    if( !EFI_ERROR(Status) ) {

        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: retrieved ConOut successfully\r\n");

        //
        // Preserve StartOfDevicePath so we can free the memory later.
        //
        DevicePath = StartOfDevicePath;

        EfiAlignDp(&DevicePathAligned,
                   DevicePath,
                   DevicePathNodeLength(DevicePath));



        //
        // Keep looking until we get to the end of the entire Device Path.
        //
        while( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                 (DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE)) &&
                (!FoundIt) ) {


            //
            // Remember the address he's holding.  This is the root
            // of this device path and we may need to look at this
            // guy again if down the path we find a UART.
            //
            RootDevicePath = DevicePath;



            //
            // Keep looking until we get to the end of this subpath.
            //
            while( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                     ((DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE) ||
                      (DevicePathAligned.DevPath.SubType == END_INSTANCE_DEVICE_PATH_SUBTYPE))) ) {


                if( (DevicePathAligned.DevPath.Type    == MESSAGING_DEVICE_PATH) &&
                    (DevicePathAligned.DevPath.SubType == MSG_UART_DP) &&
                    (FoundIt == FALSE) ) {


                    //
                    // We got a UART.  Pickup the settings.
                    //
                    UartDevicePath = (UART_DEVICE_PATH *)&DevicePathAligned;
                    LoaderRedirectionInformation.BaudRate = (ULONG)UartDevicePath->BaudRate;
                    LoaderRedirectionInformation.Parity = (BOOLEAN)UartDevicePath->Parity;
                    LoaderRedirectionInformation.StopBits = (UCHAR)UartDevicePath->StopBits;


                    //
                    // Fixup BaudRate if necessary.  If it's 0, then we're
                    // supposed to use the default for this h/w.  We're going
                    // to override to 9600 though.
                    //
                    if( LoaderRedirectionInformation.BaudRate == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_9600;
                    }

                    if( LoaderRedirectionInformation.BaudRate > BD_115200 ) {
                        LoaderRedirectionInformation.BaudRate = BD_115200;
                    }

                    DBG_TRACE(L"BlRetrieveBIOSRedirectionInformation: found a UART\r\n");

                    //
                    // Remember that we found a UART and quit searching.
                    //
                    FoundIt = TRUE;

                }

                if( (FoundIt == TRUE) && // we already found a UART, so we're on the right track.
                    (DevicePathAligned.DevPath.Type    == MESSAGING_DEVICE_PATH) &&
                    (DevicePathAligned.DevPath.SubType == MSG_VENDOR_DP) ) {

                    VENDOR_DEVICE_PATH  *VendorDevicePath = (VENDOR_DEVICE_PATH *)&DevicePathAligned;
                    EFI_GUID            PcAnsiGuid = DEVICE_PATH_MESSAGING_PC_ANSI;

                    //
                    // See if the UART is a VT100 or ANSI or whatever.
                    //
                    if( memcmp( &VendorDevicePath->Guid, &PcAnsiGuid, sizeof(EFI_GUID)) == 0 ) {
                        LoaderRedirectionInformation.TerminalType = 3;
                    } else {

                        // Default to VT100
                        LoaderRedirectionInformation.TerminalType = 0;
                    }
                }


                //
                // Get the next structure in our packed array.
                //
                DevicePath = NextDevicePathNode( DevicePath );

                EfiAlignDp(&DevicePathAligned,
                           DevicePath,
                           DevicePathNodeLength(DevicePath));
            
            }


            //
            // Do we need to keep going?  Check to make sure we're not at the
            // end of the entire packed array of device paths.
            //
            if( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                  (DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE)) ) {

                //
                // Yes.  Get the next entry.
                //
                DevicePath = NextDevicePathNode( DevicePath );

                EfiAlignDp(&DevicePathAligned,
                           DevicePath,
                           DevicePathNodeLength(DevicePath));
            }

        }

    } else {
        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: failed to get CONOUT variable\r\n");
    }


    if( FoundIt ) {


        //
        // We found a UART, but we were already too far down the list
        // in the device map to get the address, which is really what
        // we're after.  Start looking at the device map again from the
        // root of the path where we found the UART.
        //
        DevicePath = RootDevicePath;


        //
        // Reset this guy so we'll know if we found a reasonable
        // ACPI_DEVICE_PATH entry.
        //
        FoundIt = FALSE;
        EfiAlignDp(&DevicePathAligned,
                   RootDevicePath,
                   DevicePathNodeLength(DevicePath));


        //
        // Keep looking until we get to the end, or until we run
        // into our UART again.
        //
        while( (DevicePathAligned.DevPath.Type != END_DEVICE_PATH_TYPE) &&
               (!FoundIt) ) {

            if( DevicePathAligned.DevPath.Type == ACPI_DEVICE_PATH ) {

                //
                // Remember the address he's holding.
                //
                AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)&DevicePathAligned;

                if( AcpiDevicePath->UID ) {

                    LoaderRedirectionInformation.PortAddress = (PUCHAR)ULongToPtr(AcpiDevicePath->UID);
                    LoaderRedirectionInformation.PortNumber = 3;

                    FoundIt = TRUE;
                }
            }


            //
            // Get the next structure in our packed array.
            //
            DevicePath = NextDevicePathNode( DevicePath );

            EfiAlignDp(&DevicePathAligned,
                       DevicePath,
                       DevicePathNodeLength(DevicePath));
        }

    }


    if( FoundIt ) {
        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: returning TRUE\r\n");
        ReturnValue = TRUE;
    }



#ifndef  DONT_USE_EFI_MEMORY
    //
    // Free the memory we allocated for StartOfDevicePath.
    //
    if( StartOfDevicePath != NULL ) {
        EfiBS->FreePool( (VOID *)StartOfDevicePath );
    }
#endif


    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();


    return( ReturnValue );

}

LOGICAL
BlPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress OPTIONAL,
    IN BOOLEAN ReInitialize,
    OUT PULONG BlFileId
    )

/*++

Routine Description:

    This functions initializes the com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.
    
    ReInitialize - Set to TRUE if we already have this port open, but for some
        reason need to completely reset the port.  Otw it should be FALSE.
    
    BlFileId - A place to store a fake file Id, if successful.

Returned Value:

    TRUE - If a debug port is found, and BlFileId will point to a location within Port[].

--*/

{
    UCHAR DebugMessage[80];
    LOGICAL Found = FALSE;

    ULONG HandleCount;
    EFI_HANDLE *SerialIoHandles;
    EFI_HANDLE DeviceHandle = NULL;
    EFI_DEVICE_PATH *DevicePath;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    ULONG i;
    ULONG Control;
    EFI_STATUS Status;
    ARC_STATUS ArcStatus;

    ArcStatus = BlGetEfiProtocolHandles(
                                    &EfiSerialIoProtocol,
                                    &SerialIoHandles,
                                    &HandleCount
                                    );

    if (ArcStatus != ESUCCESS) {
        return FALSE;
    }

    //
    // If the baud rate is not specified, then default the baud rate to 19.2.
    //

    if (BaudRate == 0) {
        BaudRate = BD_19200;
    }


    
    //
    // If the user didn't send us a port address, then
    // guess based on the COM port number.
    //
    if( PortAddress == 0 ) {

        switch (PortNumber) {
            case 1:
                PortAddress = (PUCHAR)COM1_PORT;
                break;

            case 2:
                PortAddress = (PUCHAR)COM2_PORT;
                break;

            case 3:
                PortAddress = (PUCHAR)COM3_PORT;
                break;

            default:
                PortNumber = 4;
                PortAddress = (PUCHAR)COM4_PORT;
        }

    }
        
    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    //
    // Get the device path
    //
    for (i = 0; i < HandleCount; i++) {
        DBG_TRACE( L"About to HandleProtocol\r\n");
        Status = EfiBS->HandleProtocol (
                    SerialIoHandles[i],
                    &EfiDevicePathProtocol,
                    &DevicePath
                    );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"HandleProtocol failed\r\n");
            Found = FALSE;
            goto e0;
        }

        EfiAlignDp(&DevicePathAligned,
                   DevicePath,
                   DevicePathNodeLength(DevicePath));

        AcpiDevicePath = (ACPI_HID_DEVICE_PATH *) &DevicePathAligned;

        if (PortNumber = 0) {
            Found = TRUE;
            break;
        } else if (AcpiDevicePath->UID == PtrToUlong(PortAddress)) {
            Found = TRUE;
            break;
        }
        
    }

    if (Found == TRUE) {
        DBG_TRACE( L"found the port device\r\n");
        //
        // Check if the port is already in use, and this is a first init.
        //
        if (!ReInitialize && (Port[PortNumber].Address != NULL)) {
            DBG_TRACE( L"found the port device but it's already in use\r\n");
            Found = FALSE;
            goto e0;
        }

        //
        // Check if someone tries to reinit a port that is not open.
        //
        if (ReInitialize && (Port[PortNumber].Address == NULL)) {
            DBG_TRACE( L"found the port device but we're reinitializing a port that hasn't been opened\r\n");
            Found = FALSE;
            goto e0;
        }

        DBG_TRACE( L"about to HandleProtocol for SerialIO\r\n");

        //
        // Get the interface for the serial IO protocol.
        //
        Status = EfiBS->HandleProtocol(SerialIoHandles[i],
                                       &EfiSerialIoProtocol,
                                       &SerialIoInterface
                                      );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"HandleProtocol for SerialIO failed\r\n");
            Found = FALSE;
            goto e0;
        }

        Status = SerialIoInterface->SetAttributes(SerialIoInterface,
                                                  BaudRate,
                                                  0,
                                                  0,
                                                  DefaultParity,
                                                  0,
                                                  DefaultStopBits
                                                 );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"SerialIO: SetAttributes failed\r\n");
            Found = FALSE;
            goto e0;
        }

        Control = EFI_SERIAL_DATA_TERMINAL_READY | EFI_SERIAL_CLEAR_TO_SEND;
        Status = SerialIoInterface->SetControl(SerialIoInterface,
                                               Control
                                              );
        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"SerialIO: SetControl failed\r\n");
            Found = FALSE;
            goto e0;
        }

    } else {
        DBG_TRACE( L"didn't find a port device\r\n");    
        Found = FALSE;
        goto e0;
    }


    //
    // Initialize Port[] structure.
    //
    Port[PortNumber].Address = PortAddress;
    Port[PortNumber].Baud    = BaudRate;

    *BlFileId = PortNumber;


    DBG_TRACE( L"success, we're done.\r\n");    
e0:
    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)SerialIoHandles >> PAGE_SHIFT) );
    
    return Found;
}

VOID
BlInitializeHeadlessPort(
    VOID
    )

/*++

Routine Description:

    Does x86-specific initialization of a dumb terminal connected to a serial port.  Currently, 
    it assumes baud rate and com port are pre-initialized, but this can be changed in the future 
    by reading the values from boot.ini or someplace.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UINTN               reqd;
    EFI_GUID EfiGlobalVariable  = EFI_GLOBAL_VARIABLE;
    EFI_STATUS          Status = EFI_UNSUPPORTED;

    if( (LoaderRedirectionInformation.PortNumber == 0) ||
        !(LoaderRedirectionInformation.PortAddress) ) {

        //
        // This means that no one has filled in the LoaderRedirectionInformation
        // structure, which means that we aren't redirecting right now.
        // See if the BIOS was redirecting.  If so, pick up those settings
        // and use them.
        //
        
        BlRetrieveBIOSRedirectionInformation();

        if( LoaderRedirectionInformation.PortNumber ) {


            //
            // We don't need to even bother telling anyone else in the
            // loader that we're going to need to redirect because if
            // EFI is redirecting, then the loader will be redirecting (as
            // it's just an EFI app).
            //
            BlTerminalConnected = FALSE;


            //
            // We really need to make sure there's an address associated with
            // this port and not just a port number.
            //
            if( LoaderRedirectionInformation.PortAddress == NULL ) {

                switch( LoaderRedirectionInformation.PortNumber ) {

                    case 4:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM4_PORT;
                        break;

                    case 3:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM3_PORT;
                        break;

                    case 2:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM2_PORT;
                        break;

                    case 1:
                    default:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM1_PORT;
                        break;
                }

            }

            //
            // Load in the machine's GUID
            //

            FlipToPhysical();
            reqd = sizeof(GUID);
            Status = EfiST->RuntimeServices->GetVariable( L"SystemGUID",
                                                          &EfiGlobalVariable,
                                                          NULL,
                                                          &reqd,
                                                          (VOID *)&LoaderRedirectionInformation.SystemGUID);

            FlipToVirtual();


        } else {

            BlTerminalConnected = FALSE;
        }

    }

}

LOGICAL
BlTerminalAttached(
    IN ULONG DeviceId
    )

/*++

Routine Description:

    This routine will attempt to discover if a terminal is attached.

Arguments:

    DeviceId - Value returned by BlPortInitialize()

Return Value:

    TRUE - Port seems to have something attached.

    FALSE - Port doesn't seem to have anything attached.

--*/

{
    ULONG Control;
    ULONG Flags;
    EFI_STATUS Status;
    BOOLEAN ReturnValue;
 
    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );
    if (EFI_ERROR(Status)) {
        FlipToVirtual();
        return FALSE;
    }

    Flags = EFI_SERIAL_DATA_SET_READY |
            EFI_SERIAL_CLEAR_TO_SEND  |
            EFI_SERIAL_CARRIER_DETECT;

    ReturnValue = ((Control & Flags) == Flags);

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    return ReturnValue;
}

VOID
BlSetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock
    )

/*++

Routine Description:

    This routine will fill in the areas of the restart block that are appropriate 
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.

Return Value:

    None.

--*/

{

    if( LoaderRedirectionInformation.PortNumber ) {


        RestartBlock->HeadlessUsedBiosSettings = (ULONG)LoaderRedirectionInformation.UsedBiosSettings;
        RestartBlock->HeadlessPortNumber = (ULONG)LoaderRedirectionInformation.PortNumber;
        RestartBlock->HeadlessPortAddress = (PUCHAR)LoaderRedirectionInformation.PortAddress;
        RestartBlock->HeadlessBaudRate = (ULONG)LoaderRedirectionInformation.BaudRate;
        RestartBlock->HeadlessParity = (ULONG)LoaderRedirectionInformation.Parity;
        RestartBlock->HeadlessStopBits = (ULONG)LoaderRedirectionInformation.StopBits;
        RestartBlock->HeadlessTerminalType = (ULONG)LoaderRedirectionInformation.TerminalType;

        RestartBlock->HeadlessPciDeviceId = LoaderRedirectionInformation.PciDeviceId;
        RestartBlock->HeadlessPciVendorId = LoaderRedirectionInformation.PciVendorId;
        RestartBlock->HeadlessPciBusNumber = LoaderRedirectionInformation.PciBusNumber;
        RestartBlock->HeadlessPciSlotNumber = LoaderRedirectionInformation.PciSlotNumber;
        RestartBlock->HeadlessPciFunctionNumber = LoaderRedirectionInformation.PciFunctionNumber;
        RestartBlock->HeadlessPciFlags = LoaderRedirectionInformation.PciFlags;
    }
}

VOID
BlGetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock,
    IN BOOLEAN RestartBlockValid
    )

/*++

Routine Description:

    This routine will get all the information from a restart block    
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.
        
    RestartBlockValid - Is this block valid (full of good info)?

Return Value:

    None.

--*/

{

    LoaderRedirectionInformation.UsedBiosSettings = (BOOLEAN)RestartBlock->HeadlessUsedBiosSettings;
    LoaderRedirectionInformation.DataBits = 0;
    LoaderRedirectionInformation.StopBits = (UCHAR)RestartBlock->HeadlessStopBits;
    LoaderRedirectionInformation.Parity = (BOOLEAN)RestartBlock->HeadlessParity;
    LoaderRedirectionInformation.BaudRate = (ULONG)RestartBlock->HeadlessBaudRate;;
    LoaderRedirectionInformation.PortNumber = (ULONG)RestartBlock->HeadlessPortNumber;
    LoaderRedirectionInformation.PortAddress = (PUCHAR)RestartBlock->HeadlessPortAddress;
    LoaderRedirectionInformation.TerminalType = (UCHAR)RestartBlock->HeadlessTerminalType;

    LoaderRedirectionInformation.PciDeviceId = (USHORT)RestartBlock->HeadlessPciDeviceId;
    LoaderRedirectionInformation.PciVendorId = (USHORT)RestartBlock->HeadlessPciVendorId;
    LoaderRedirectionInformation.PciBusNumber = (UCHAR)RestartBlock->HeadlessPciBusNumber;
    LoaderRedirectionInformation.PciSlotNumber = (UCHAR)RestartBlock->HeadlessPciSlotNumber;
    LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)RestartBlock->HeadlessPciFunctionNumber;
    LoaderRedirectionInformation.PciFlags = (ULONG)RestartBlock->HeadlessPciFlags;

}

ULONG
BlPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it.

Arguments:

    BlFileId - The port to read from.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    ULONGLONG BufferSize = 1;
    EFI_STATUS Status;

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->Read(SerialIoInterface,
                                     &BufferSize,
                                     Input
                                    );

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    switch (Status) {
    case EFI_SUCCESS:
        return CP_GET_SUCCESS;
    case EFI_TIMEOUT:
        return CP_GET_NODATA;
    default:
        return CP_GET_ERROR;
    }
}

VOID
BlPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the port.

Arguments:

    BlFileId - The port to write to.

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
    ULONGLONG BufferSize = 1;
    ULONG Control;
    EFI_STATUS Status;

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->Write(SerialIoInterface,
                                      &BufferSize,
                                      &Output
                                     );
    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

}

ULONG
BlPortPollByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it if one is available.

Arguments:

    BlFileId - The port to poll.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    ULONGLONG BufferSize = 1;
    ULONG Control;
    EFI_STATUS Status;
 
    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );
    if (EFI_ERROR(Status)) {
        FlipToVirtual();
        return CP_GET_ERROR;
    }


    if (Control & EFI_SERIAL_INPUT_BUFFER_EMPTY) {
        FlipToVirtual();
        return CP_GET_NODATA;
    } else {
        Status = SerialIoInterface->Read(SerialIoInterface,
                                         &BufferSize,
                                         Input
                                        );
        FlipToVirtual();

        switch (Status) {
        case EFI_SUCCESS:
            return CP_GET_SUCCESS;
        case EFI_TIMEOUT:
            return CP_GET_NODATA;
        default:
            return CP_GET_ERROR;
        }
    }
}

ULONG
BlPortPollOnly (
    IN ULONG BlFileId
    )

/*++

Routine Description:

    Check if a byte is available

Arguments:

    BlFileId - The port to poll.

Return Value:

    CP_GET_SUCCESS is returned if a byte is ready.
    CP_GET_ERROR is returned if error encountered.
    CP_GET_NODATA is returned if timeout.

--*/

{
    EFI_STATUS Status;
    ULONG Control;
    ULONG RetVal;

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    switch (Status) {
    case EFI_SUCCESS:
        if (Control & EFI_SERIAL_INPUT_BUFFER_EMPTY)
            return CP_GET_NODATA;
        else
            return CP_GET_SUCCESS;
    case EFI_TIMEOUT:
        return CP_GET_NODATA;
    default:
        return CP_GET_ERROR;

        typedef enum _EXPORT_ENTRY {
    ExRebootProcessor,
    ExGetSector,
    ExGetKey,
    ExGetCounter,
    ExReboot,
    ExAbiosServices,
    ExDetectHardware,
    ExHardwareCursor,
    ExGetDateTime,
    ExComPort,
    ExIsMcaMachine,
    ExGetStallCount,
    ExInitializeDisplayForNt,
    ExGetMemoryDescriptor,
    ExGetEddsSector,
    ExGetElToritoStatus,
    ExGetExtendedInt13Params,
	ExNetPcRomServices,
    ExAPMAttemptReconnect,
    ExBiosRedirectService,
    ExMaximumRoutine
} EXPORT_ENTRY;

//
// Define ABIOS services table.
//
typedef enum _ABIOS_SERVICES {
    FAbiosIsAbiosPresent,
    FAbiosGetMachineConfig,
    FAbiosInitializeSpt,
    FAbiosBuildInitTable,
    FAbiosInitializeDbsFtt,
    FAbiosMaximumRoutine
    ABIOS_SERVICES;

    EFI_GUID EfiLoadedImageProtocol = LOADED_IMAGE_PROTOCOL;
EFI_GUID EfiDevicePathProtocol  = DEVICE_PATH_PROTOCOL;
EFI_GUID EfiDeviceIoProtocol    = DEVICE_IO_PROTOCOL;
EFI_GUID EfiBlockIoProtocol     = BLOCK_IO_PROTOCOL;
EFI_GUID EfiDiskIoProtocol  = DISK_IO_PROTOCOL;
EFI_GUID EfiFilesystemProtocol  = SIMPLE_FILE_SYSTEM_PROTOCOL;


EFI_GUID AcpiTable_Guid         = ACPI_TABLE_GUID;
EFI_GUID SmbiosTableGuid        = SMBIOS_TABLE_GUID;
EFI_GUID SalSystemTableGuid     = SAL_SYSTEM_TABLE_GUID;

//
// PAL, SAL, and IO port space data
//

ULONGLONG   PalProcVirtual;
ULONGLONG   PalProcPhysical;
ULONGLONG   PalPhysicalBase = 0;
ULONGLONG   PalTrPs;

ULONGLONG   IoPortPhysicalBase;
ULONGLONG   IoPortTrPs;

//
// Function Prototypes
//

VOID
GetPalProcEntryPoint(
    IN PSST_HEADER SalSystemTable
    );

ULONG
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    );

VOID
ConstructMemoryDescriptors(
    VOID
    );

MEMORY_TYPE
EfiToArcType (
    UINT32 Type
    );

VOID
AdjustMemoryDescriptorSizes(
    VOID
    );


#if DBG
#define DBG_TRACE(_X) EfiST->ConOut->OutputString(EfiST->ConOut, (_X))
#else
#define DBG_TRACE(_X)
#endif

#ifdef FORCE_CD_BOOT

EFI_HANDLE
GetCd(
    );

EFI_HANDLE
GetCdTest(
    VOID
    );

#endif // for FORCE_CD_BOOT


VOID
SuMain(
    IN EFI_HANDLE          ImageHandle,
    IN EFI_SYSTEM_TABLE    *SystemTable
    )
/*++

Routine Description:

    Main entrypoint of the SU module. Control is passed from the boot
    sector to startup.asm which does some run-time fixups on the stack
    and data segments and then passes control here.

Arguments:

    None

Returns:

    Does not return. Passes control to the OS loader


--*/
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG NumberOfSections;
    BOOLEAN ResourceFound = FALSE;

    ULONGLONG Source,Destination;
    ULONGLONG VirtualSize;
    ULONGLONG SizeOfRawData;
    USHORT Section;

    EFI_GUID EfiLoadedImageProtocol = LOADED_IMAGE_PROTOCOL;
    EFI_HANDLE EfiHandleArray[EFI_ARRAY_SIZE];
    ULONG EfiHandleArraySize = EFI_ARRAY_SIZE * sizeof(EFI_HANDLE);
    EFI_DEVICE_PATH *EfiDevicePath;
    EFI_LOADED_IMAGE *EfiImageInfo;
    EFI_HANDLE DeviceHandle;
    EFI_STATUS Status;

    EFI_DEVICE_PATH *DevicePath, *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    HARDDRIVE_DEVICE_PATH *HdDevicePath;
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    ATAPI_DEVICE_PATH *AtapiDevicePath;
    SCSI_DEVICE_PATH *ScsiDevicePath;
    IPv4_DEVICE_PATH *IpV4DevicePath;
    IPv6_DEVICE_PATH *IpV6DevicePath;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *UnknownDevicePath;

    UCHAR MemoryMap[EFI_PAGE_SIZE];
    ULONGLONG MemoryMapSize = EFI_PAGE_SIZE;
    EFI_MEMORY_DESCRIPTOR *EfiMd;    
    ULONGLONG DescriptorSize;
    ULONG DescriptorVersion;

    ULONG i;
    ULONGLONG PalSize;
    ULONGLONG PalEnd;
    ULONGLONG IoPortSize;
    ULONGLONG MdPhysicalEnd;

    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_FLOPPY BootDeviceFloppy;
    PBOOT_DEVICE_IPv4 BootDeviceIpV4;
    PBOOT_DEVICE_IPv6 BootDeviceIpV6;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;

    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    PUCHAR SMBiosEPSPtr;
    UCHAR CheckSum;


    //
    // EFI global variables
    //
    EfiImageHandle = ImageHandle;
    EfiST = SystemTable;
    EfiBS = SystemTable->BootServices;
    EfiRS = SystemTable->RuntimeServices;

    DBG_TRACE(L"SuMain: entry\r\n");

    //
    // Get the SAL System Table
    //
    Status = GetSystemConfigurationTable(&SalSystemTableGuid, &SalSystemTable);
    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

#if 0
    //
    // Get the MPS Table
    //
    Status = GetSystemConfigurationTable(&MpsTableGuid, &MpsTable);
    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }
#endif
    //
    // Get the ACPI Tables
    //

    //
    // Get the ACPI 2.0 Table, if present
    //
    //DbgPrint("Looking for ACPi 2.0\n");
    Status = GetSystemConfigurationTable(&AcpiTable_Guid, &AcpiTable);
    if (EFI_ERROR(Status)) {
        //DbgPrint("returned error\n");
        AcpiTable = NULL;
    }

  //DbgPrint("AcpiTable: %p\n", AcpiTable);

    if (!AcpiTable) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                            L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }


    //
    // Get the SMBIOS Table
    //
    Status = GetSystemConfigurationTable(&SmbiosTableGuid, &SMBiosTable);
    if (EFI_ERROR(Status)) {
        //DbgPrint("returned error\n");
        SMBiosTable = NULL;
    } else {
        //
        // Validate SMBIOS EPS Header
        //
        SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)SMBiosTable;
        SMBiosEPSPtr = (PUCHAR)SMBiosTable;
        
        if ((*((PULONG)SMBiosEPSHeader->Signature) == SMBIOS_EPS_SIGNATURE) &&
            (SMBiosEPSHeader->Length >= sizeof(SMBIOS_EPS_HEADER)) &&
            (*((PULONG)SMBiosEPSHeader->Signature2) == DMI_EPS_SIGNATURE) && 
            (SMBiosEPSHeader->Signature2[4] == '_' ))
        {
            CheckSum = 0;
            for (i = 0; i < SMBiosEPSHeader->Length ; i++)
            {
                CheckSum += SMBiosEPSPtr[i];
            }

            if (CheckSum != 0)
            {
                DBG_TRACE(L"SMBios Table has bad checksum.....\n");
                SMBiosTable = NULL;
            } else {
                DBG_TRACE(L"SMBios Table has been validated.....\n");
            }
            
        } else {
            DBG_TRACE(L"SMBios Table is incorrectly formed.....\n");
            SMBiosTable = NULL;
        }       
    }                                                                     
    
    //
    // Get the image info for NTLDR
    //
    Status = EfiBS->HandleProtocol (
                ImageHandle,
                &EfiLoadedImageProtocol,
                &EfiImageInfo
                );

    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // Get device path of the DeviceHandle associated with this image handle.
    //
    Status = EfiBS->HandleProtocol (
                EfiImageInfo->DeviceHandle,
                &EfiDevicePathProtocol,
                &DevicePath
                );

    if (EFI_ERROR(Status)) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: HandleProtocol failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // Get the MediaType and Partition information and save them in the
    // BootContext.
    //
    EfiAlignDp( &TestPathAligned,
                 DevicePath,
                 DevicePathNodeLength(DevicePath) );


    TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

    while (TestPath->Type != END_DEVICE_PATH_TYPE) {

        if (TestPath->Type == MESSAGING_DEVICE_PATH) {
            if (TestPath->SubType == MSG_ATAPI_DP) {
                AtapiDevicePath = (ATAPI_DEVICE_PATH *) TestPath;
                BootContext.BusType = BootBusAtapi;
                BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContext.BootDevice);

                BootDeviceAtapi->PrimarySecondary = AtapiDevicePath->PrimarySecondary;
                BootDeviceAtapi->SlaveMaster = AtapiDevicePath->SlaveMaster;
                BootDeviceAtapi->Lun = AtapiDevicePath->Lun;
            } else if (TestPath->SubType == MSG_SCSI_DP) {
                ScsiDevicePath = (SCSI_DEVICE_PATH *) TestPath;
                BootContext.BusType = BootBusScsi;
                BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContext.BootDevice);

                BootDeviceScsi->Pun = ScsiDevicePath->Pun;
                BootDeviceScsi->Lun = ScsiDevicePath->Lun;
            } else if (TestPath->SubType == MSG_MAC_ADDR_DP) {
                BootContext.MediaType = BootMediaTcpip;
            } else if (TestPath->SubType == MSG_IPv4_DP) {
                IpV4DevicePath = (IPv4_DEVICE_PATH *) TestPath;
                BootContext.MediaType = BootMediaTcpip;
                BootDeviceIpV4 = (PBOOT_DEVICE_IPv4) &(BootContext.BootDevice);

                BootDeviceIpV4->RemotePort = IpV4DevicePath->RemotePort;
                BootDeviceIpV4->LocalPort = IpV4DevicePath->LocalPort;
                RtlCopyMemory(&BootDeviceIpV4->Ip, &IpV4DevicePath->LocalIpAddress, sizeof(EFI_IPv4_ADDRESS));
            } else if (TestPath->SubType == MSG_IPv6_DP) {
                IpV6DevicePath = (IPv6_DEVICE_PATH *) TestPath;
                BootContext.MediaType = BootMediaTcpip;
                BootDeviceIpV6 = (PBOOT_DEVICE_IPv6) &(BootContext.BootDevice);

                BootDeviceIpV6->RemotePort = IpV6DevicePath->RemotePort;
                BootDeviceIpV6->LocalPort = IpV6DevicePath->LocalPort;
#if 0
                BootDeviceIpV6->Ip = IpV6DevicePath->Ip;
#endif
            }
        } else if (TestPath->Type == ACPI_DEVICE_PATH) {
            AcpiDevicePath = (ACPI_HID_DEVICE_PATH *) TestPath;
            if (AcpiDevicePath->HID == EISA_ID(PNP_EISA_ID_CONST, 0x0303)) {
                BootDeviceFloppy = (PBOOT_DEVICE_FLOPPY) &(BootContext.BootDevice);
                BootDeviceFloppy->DriveNumber = AcpiDevicePath->UID;
            }
        } else if (TestPath->Type == HARDWARE_DEVICE_PATH) {
            if (TestPath->SubType == HW_VENDOR_DP) {
                UnknownDevicePath = (UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath;
                BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContext.BootDevice);
                RtlCopyMemory( &(BootDeviceUnknown->Guid),
                               &(UnknownDevicePath->DevicePath.Guid),
                               sizeof(EFI_GUID));

                BootContext.BusType = BootBusVendor;
                BootDeviceUnknown->LegacyDriveLetter = UnknownDevicePath->LegacyDriveLetter;
            }
        } else if (TestPath->Type == MEDIA_DEVICE_PATH) {
            BootContext.MediaType = TestPath->SubType;
            if (TestPath->SubType == MEDIA_HARDDRIVE_DP) {
                HdDevicePath = (HARDDRIVE_DEVICE_PATH *) TestPath;

                BootContext.MediaType = BootMediaHardDisk;
                BootContext.PartitionNumber = (UCHAR) HdDevicePath->PartitionNumber;
            } else if (TestPath->SubType == MEDIA_CDROM_DP) {
                BootContext.MediaType = BootMediaCdrom;
            }
        }

        DevicePath = NextDevicePathNode(DevicePath);
        EfiAlignDp( &TestPathAligned,
                      DevicePath,
                      DevicePathNodeLength(DevicePath) );
        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
    }

#ifdef  FORCE_CD_BOOT
    BootContext.MediaType = BootMediaCdrom;
#endif
    //
    // Fill out the rest of BootContext fields
    //

    DosHeader = EfiImageInfo->ImageBase;
    NtHeader = (PIMAGE_NT_HEADERS) ((PUCHAR) DosHeader + DosHeader->e_lfanew);
    FileHeader =  &(NtHeader->FileHeader);
    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)
                     ((PUCHAR)FileHeader + sizeof(IMAGE_FILE_HEADER));
    SectionHeader = (PIMAGE_SECTION_HEADER) ((PUCHAR)OptionalHeader +
                                             FileHeader->SizeOfOptionalHeader);

    BootContext.ExternalServicesTable = (PEXTERNAL_SERVICES_TABLE)
                                        &ExportEntryTable;

    BootContext.MachineType          = MACHINE_TYPE_ISA;

    BootContext.OsLoaderBase         = (ULONG_PTR)EfiImageInfo->ImageBase;
    BootContext.OsLoaderExports = (ULONG_PTR)EfiImageInfo->ImageBase +
                                  OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

    //
    // Calculate the start address and the end address of OS loader.
    //

    BootContext.OsLoaderStart        = (ULONG_PTR)EfiImageInfo->ImageBase +
                                       SectionHeader->VirtualAddress;
    BootContext.OsLoaderEnd          = (ULONG_PTR)EfiImageInfo->ImageBase +
                                       SectionHeader->SizeOfRawData;

    for (Section=FileHeader->NumberOfSections ; Section-- ; SectionHeader++) {
        Destination = (ULONG_PTR)EfiImageInfo->ImageBase + SectionHeader->VirtualAddress;
        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;

        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }
        if (Destination < BootContext.OsLoaderStart) {
            BootContext.OsLoaderStart = Destination;
        }
        if (Destination+VirtualSize > BootContext.OsLoaderEnd) {
            BootContext.OsLoaderEnd = Destination+VirtualSize;
        }
    }

    //
    // Find .rsrc section
    //
    SectionHeader = (PIMAGE_SECTION_HEADER) ((PUCHAR)OptionalHeader +
                                             FileHeader->SizeOfOptionalHeader);
    NumberOfSections = FileHeader->NumberOfSections;
    while (NumberOfSections) {
        if (_stricmp(SectionHeader->Name, ".rsrc")==0) {
            BootContext.ResourceDirectory =
                    (ULONGLONG) ((ULONG_PTR)EfiImageInfo->ImageBase + SectionHeader->VirtualAddress);

            BootContext.ResourceOffset = (ULONGLONG)((LONG)SectionHeader->VirtualAddress);
            ResourceFound = TRUE;
        }

        ++SectionHeader;
        --NumberOfSections;
    }

    if (ResourceFound == FALSE) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: Resource section not found\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    DBG_TRACE( L"SuMain: About to call NtProcessStartup\r\n");


    //
    // See if someone called us w/ a TFTP restart block.
    //
    if( EfiImageInfo->LoadOptionsSize == (sizeof(TFTP_RESTART_BLOCK)) ) {
        
        //
        // Likely.  Make sure it's really a TFTP restart block and if so, go retrieve all
        // its contents.
        //
        if( EfiImageInfo->LoadOptions != NULL ) {

            extern TFTP_RESTART_BLOCK       gTFTPRestartBlock;
            PTFTP_RESTART_BLOCK             restartBlock = NULL;

            restartBlock = (PTFTP_RESTART_BLOCK)(EfiImageInfo->LoadOptions);

            RtlCopyMemory( &gTFTPRestartBlock,
                           restartBlock,
                           sizeof(TFTP_RESTART_BLOCK) );

            DBG_TRACE( L"SuMain: copied TFTP_RESTART_BLOCK into gTFTPRestartBlock\r\n");
        }
    }

    ConstructMemoryDescriptors( );

    GetPalProcEntryPoint( SalSystemTable );

    //
    // Applies CPU specific workarounds
    //

    CpuSpecificWork();

    SuFillExportTable( );

    NtProcessStartup( &BootContext );

}

VOID
ConstructMemoryDescriptors(
    VOID
    )
/*++

Routine Description:

    Builds up memory descriptors for the OS loader.  This routine queries EFI 
    for it's memory map (a variable sized array of EFI_MEMORY_DESCRIPTOR's).  
    It then allocates sufficient space for the MDArray global (a variable sized
    array of  ARC-based MEMORY_DESCRIPTOR's.)  The routine then maps the EFI
    memory map to the ARC memory map, carving out all of the conventional 
    memory space for the EFI loader to help keep the memory map intact.  We 
    must leave behind some amount of memory for the EFI boot services to use,
    which we allocate as conventional memory in our map.

Arguments:

    None

Returns:

    Nothing.  Fills in the MDArray global variable.  If this routine encounters
    an error, it is treated as fatal and the program exits.


--*/
{
    EFI_STATUS Status;
    ULONGLONG MemoryMapSize = 0;
    EFI_MEMORY_DESCRIPTOR *EfiMd;    
    ULONGLONG DescriptorSize;
    ULONG DescriptorVersion;

    ULONG i;
    ULONGLONG PalSize;
    ULONGLONG PalEnd;
    ULONGLONG IoPortSize;
    ULONGLONG MdPhysicalStart;
    ULONGLONG MdPhysicalEnd;
    ULONGLONG MdPhysicalSize;


    //
    // Get memory map info from EFI firmware
    //
    // To do this, we first find out how much space we need by calling
    // with an empty buffer.
    //
    EfiMd = NULL;

    Status = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                EfiMd,
                &MemoryMapKey,
                &DescriptorSize,
                &DescriptorVersion
                );

    if (Status != EFI_BUFFER_TOO_SMALL) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: GetMemoryMap failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // We are going to make three extra allocations before we call GetMemoryMap
    // again, so add some extra space.
    //
    // 1. EfiMD
    // 2. MDarray
    // 3. Split out memory above and below 80MB (on ia64)
    //
    MemoryMapSize += 3*DescriptorSize;


    i = (ULONG) MemoryMapSize;

    //
    // now allocate space for the EFI-based memory map and assign it to the loader
    //
    Status = EfiBS->AllocatePool(EfiLoaderData,i,&EfiMd);
    if (EFI_ERROR(Status)) {
        DBG_TRACE( L"SuMain: AllocatePool failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }


    //
    // now Allocate and zero the MDArray, which is the native loader memory 
    // map which we need to map the EFI memory map to.
    //
    // The MDArray has one entry for each EFI_MEMORY_DESCRIPTOR, and each entry
    // is MEMORY_DESCRIPTOR large.
    //

    i=((ULONG)(MemoryMapSize / DescriptorSize)+1)*sizeof (MEMORY_DESCRIPTOR);

    Status = EfiBS->AllocatePool(EfiLoaderData,i,&MDArray);
    if (EFI_ERROR(Status)) {
        DBG_TRACE (L"SuMain: AllocatePool failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // caution, this is 0 based!
    //
    MaxDescriptors = (ULONG)((MemoryMapSize / DescriptorSize)+1);

    RtlZeroMemory (MDArray,i);

    if ((EfiMd == NULL)) {
        DBG_TRACE (L"SuMain: Failed to Allocate Memory for the descriptor lists\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // we have all of the memory allocated at this point, so retreive the
    // memory map again, which should succeed the second time.
    //
    Status = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                EfiMd,
                &MemoryMapKey,
                &DescriptorSize,
                &DescriptorVersion
                );

    if (EFI_ERROR(Status)) {
        DBG_TRACE(L"SuMain: GetMemoryMap failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now walk the EFI_MEMORY_DESCRIPTOR array, mapping each
    // entry to an arc-based MEMORY_DESCRIPTOR.
    //
    // MemoryMapSize contains actual size of the memory descriptor array.
    //
    for (i = 0; MemoryMapSize > 0; i++) {
#if DBG_MEMORY
            wsprintf( DebugBuffer, 
                      L"PageStart (%x), Size (%x), Type (%x)\r\n", 
                      (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT), 
                      EfiMd->NumberOfPages,
                      EfiMd->Type);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
            DBG_EFI_PAUSE();
#endif


        if (EfiMd->NumberOfPages > 0) {
            MdPhysicalStart = EfiMd->PhysicalStart;
            MdPhysicalEnd = EfiMd->PhysicalStart + (EfiMd->NumberOfPages << EFI_PAGE_SHIFT);
            MdPhysicalSize = MdPhysicalEnd - MdPhysicalStart;

#if DBG_MEMORY
            wsprintf( DebugBuffer, 
                      L"PageStart %x (%x), PageEnd %x (%x), Type (%x)\r\n", 
                      MdPhysicalStart, (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT), 
                      MdPhysicalEnd, (EfiMd->PhysicalStart >>EFI_PAGE_SHIFT) + EfiMd->NumberOfPages,
                      EfiMd->Type);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
            DBG_EFI_PAUSE();
#endif
            

            //
            // Insert conventional memory descriptors with WB flag set
            // into NT loader memory descriptor list.
            //
            if ( (EfiMd->Type == EfiConventionalMemory) &&
                 ((EfiMd->Attribute & EFI_MEMORY_WB) == EFI_MEMORY_WB) ) {
                ULONGLONG AmountOfMemory;
                ULONG NumberOfEfiPages;
                BOOLEAN FirstTime = TRUE;
                //
                // Allocate pages between the start and _80MB line for 
                // the loader to manage.  We don't use anything above this range, so 
                // just leave that memory alone
                //
                if ((MdPhysicalStart < (_80MB << PAGE_SHIFT)) &&
                    (MdPhysicalEnd > (_80MB << PAGE_SHIFT))) {
                    
                    AmountOfMemory = (_80MB << PAGE_SHIFT)  - EfiMd->PhysicalStart;
                    //
                    // record the pages in EFI page size
                    //
                    NumberOfEfiPages = (ULONG)(AmountOfMemory >> EFI_PAGE_SHIFT);
                    
                    //
                    // try to align it.
                    //
                    if ((NumberOfEfiPages % ((1 << PAGE_SHIFT) >> EFI_PAGE_SHIFT) != 0) && 
                        (NumberOfEfiPages + (PAGE_SHIFT - EFI_PAGE_SHIFT) <= EfiMd->NumberOfPages )) {
                        NumberOfEfiPages += (PAGE_SHIFT - EFI_PAGE_SHIFT);
                    }
                    
                    Status = EfiBS->AllocatePages ( AllocateAddress,
                                                EfiLoaderData,
                                                NumberOfEfiPages,
                                                &(EfiMd->PhysicalStart) );

#if DBG_MEMORY
                    wsprintf( DebugBuffer, 
                      L"allocate pages @ %x size = %x\r\n", 
                      (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT), 
                      NumberOfEfiPages);
                    EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
                    DBG_EFI_PAUSE();
#endif


                    if (EFI_ERROR(Status)) {
                        EfiST->ConOut->OutputString(EfiST->ConOut,
                                                    L"SuMain: AllocPages failed\n");
                        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
                    }                    

                    MdPhysicalEnd = MdPhysicalStart + (NumberOfEfiPages << EFI_PAGE_SHIFT);
                    MdPhysicalSize = MdPhysicalEnd - MdPhysicalStart;

                    //
                    // If PalPhysicalBase is not 0, then do not report the memory
                    // from the end of PAL to the next larger page size to avoid
                    // memory aliasing in the kernel.
                    //
                    // we assume that we get the PAL memory in the memory map 
                    // before any conventional memory
                    //
                    while (1) {
                    
                        if (PalPhysicalBase != 0) {
                            //
                            // If the descriptor is completely before or after
                            // the PAL base, just insert it like a normal descriptor
                            //
                            if ( ((MdPhysicalStart < PalPhysicalBase) &&
                                  (MdPhysicalEnd <= PalPhysicalBase)) ||
                                  (MdPhysicalStart >= PalEnd)) {
                                InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                                  (ULONG)(MdPhysicalSize >> EFI_PAGE_SHIFT),
                                                  MemoryFirmwareTemporary ); 
                            }
                            //
                            // else the descriptors must somehow overlap (how 
                            // could this be possible?
                            //
                            else  {
                                if (MdPhysicalStart < PalPhysicalBase) {
                                    
                                    ASSERT( MdPhysicalEnd > PalPhysicalBase );
                                    
                                    EfiST->ConOut->OutputString(EfiST->ConOut,
                                                        L"SuMain: overlapping descriptor with PAL #1\n");
                                    //
                                    // Insert a descriptor from the start of 
                                    // the memory range to the start of the PAL
                                    // code
                                    //
                                    InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                                      (ULONG)((PalPhysicalBase - MdPhysicalStart) >> EFI_PAGE_SHIFT),
                                                      EfiToArcType(EfiMd->Type));
                                }
        
                                if (MdPhysicalEnd > PalEnd) {
                                    //
                                    // Insert a descriptor from the end of the
                                    // PAL code to the end of the memory range
                                    //
                                    InsertDescriptor( (ULONG)(PalEnd >> EFI_PAGE_SHIFT),
                                                      (ULONG)((MdPhysicalEnd - PalEnd) >> EFI_PAGE_SHIFT),
                                                      EfiToArcType(EfiMd->Type));
                                }
                            }
                        } else {
                            //
                            // Insert the descriptor
                            //
                            // hack -- set the memory type to "permanent" so that we
                            // don't merge it with the prior descriptor.  We'll set it 
                            // back to the correct type after we return.
                            //
                            InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                              (ULONG)((ULONGLONG)MdPhysicalSize >> EFI_PAGE_SHIFT),
                                              FirstTime? LoaderFree : LoaderFirmwarePermanent);
                                                        
                        }

                        if (!FirstTime) {
                            MDArray[NumberDescriptors-1].MemoryType = LoaderFirmwareTemporary;
                            break;
                        } else {
                            //
                            // go through again with the rest of the memory descriptor
                            // 
                            MdPhysicalEnd = MdPhysicalStart + (EfiMd->NumberOfPages << EFI_PAGE_SHIFT);
                            MdPhysicalStart += MdPhysicalSize;
                            MdPhysicalSize = MdPhysicalEnd - MdPhysicalStart;

#if DBG_MEMORY
                            wsprintf( DebugBuffer, 
                              L"change start @ %x --> @ %x size %x --> %x\r\n", 
                              (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT),
                              (MdPhysicalStart >> EFI_PAGE_SHIFT),
                              EfiMd->NumberOfPages,
                              (EfiMd->NumberOfPages-NumberOfEfiPages) );
                            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
                            DBG_EFI_PAUSE();
#endif

                            FirstTime = FALSE;
                        }
                    }
                } else {
                    //
                    // just insert it
                    //
                    InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                      (ULONG)((ULONGLONG)MdPhysicalSize >> EFI_PAGE_SHIFT),
                                      EfiToArcType(EfiMd->Type));
                }
            } else if ( (EfiMd->Type == EfiLoaderCode) ||
                        (EfiMd->Type == EfiLoaderData) ) {
                //
                // just insert EfiLoaderCode and EfiLoaderData verbatim
                //
                InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                  (ULONG)(MdPhysicalSize >> EFI_PAGE_SHIFT),
                                  EfiToArcType(EfiMd->Type));
            } else if (EfiMd->Type == EfiPalCode)    {
                //
                // save off the Pal stuff for later
                //
                PalPhysicalBase = EfiMd->PhysicalStart;
                PalSize = EfiMd->NumberOfPages << EFI_PAGE_SHIFT;
                PalEnd = EfiMd->PhysicalStart + PalSize;
                MEM_SIZE_TO_PS(PalSize, PalTrPs);
            } else if (EfiMd->Type == EfiMemoryMappedIOPortSpace)    {
                //
                // save off the Io stuff for later
                //
                IoPortPhysicalBase = EfiMd->PhysicalStart;
                IoPortSize = EfiMd->NumberOfPages << EFI_PAGE_SHIFT;
                MEM_SIZE_TO_PS(IoPortSize, IoPortTrPs);
            } else if (EfiMd->Type == EfiMemoryMappedIO)    {
                //
                // just ignore this type since it's not real memory -- the 
                // system can use ACPI tables to get at this later on.
                //
            } else {
                //
                // some other type -- just insert it without any changes
                //
                InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                  (ULONG)(MdPhysicalSize >> EFI_PAGE_SHIFT),
                                  EfiToArcType(EfiMd->Type));
            }
        }

        EfiMd = (EFI_MEMORY_DESCRIPTOR *) ( (PUCHAR) EfiMd + DescriptorSize );
        MemoryMapSize -= DescriptorSize;

    }

    //
    // we've built the memory descriptors with EFI_PAGE_SIZE resolution.
    // if the page sizes don't match, we post-process it here to get the
    // resolution correct
    //
    if (PAGE_SHIFT != EFI_PAGE_SHIFT) {
        AdjustMemoryDescriptorSizes();
    }
}


VOID
GetPalProcEntryPoint(
    IN PSST_HEADER SalSystemTable
    )
{
    PVOID NextEntry;
    PPAL_SAL_ENTRY_POINT PalSalEntryPoint;
    PSAL_MEMORY_DESCRIPTOR PSalMem;
    ULONG PalFreeEnd;
    ULONGLONG PalProcOffset;
    ULONG i;

    //
    // Get PalProc entry point from SAL System Table
    //
    NextEntry = (PUCHAR) SalSystemTable + sizeof(SST_HEADER);
    for (i = 0; i < SalSystemTable->EntryCount; i++) {
        switch ( *(PUCHAR)NextEntry ) {
           case PAL_SAL_EP_TYPE:
               PalSalEntryPoint = (PPAL_SAL_ENTRY_POINT) NextEntry;
               PalProcPhysical = PalSalEntryPoint->PalEntryPoint;

               PalProcOffset = PalPhysicalBase - PalProcPhysical;
               PalProcVirtual = VIRTUAL_PAL_BASE + PalProcOffset;

               ((PPAL_SAL_ENTRY_POINT)NextEntry)++;
               break;
           case SAL_MEMORY_TYPE:
               ((PSAL_MEMORY_DESCRIPTOR)NextEntry)++;
               break;
           case PLATFORM_FEATURES_TYPE:
               ((PPLATFORM_FEATURES)NextEntry)++;
               break;
           case TRANSLATION_REGISTER_TYPE:
               ((PTRANSLATION_REGISTER)NextEntry)++;
               break;
           case PTC_COHERENCE_TYPE:
               ((PPTC_COHERENCE_DOMAIN)NextEntry)++;
               break;
           case AP_WAKEUP_TYPE:
               ((PAP_WAKEUP_DESCRIPTOR)NextEntry)++;
               break;
           default:
               EfiST->ConOut->OutputString(EfiST->ConOut,
                                           L"SST: Invalid SST entry\n");
               EfiBS->Exit(EfiImageHandle, 0, 0, 0);
        }
    }
}

ULONG
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    )
{
    EFI_DEVICE_PATH *Start;

    //
    // Search for the end of the device path structure
    //
    Start = DevPath;
    while (DevPath->Type != END_DEVICE_PATH_TYPE) {
        DevPath = NextDevicePathNode(DevPath);
    }

    //
    // Compute the size
    //
    return ((UCHAR) DevPath - (UCHAR) Start);
}


MEMORY_TYPE
EfiToArcType (
    UINT32 Type
    )
/*++

Routine Description:

    Maps an EFI memory type to an Arc memory type.  We only care about a few
    kinds of memory, so this list is incomplete.

Arguments:

    Type - an EFI memory type

Returns:

    A MEMORY_TYPE enumerated type.

--*/
{
    MEMORY_TYPE typeRet=MemoryFirmwarePermanent;


    switch (Type) {
        case EfiLoaderCode:
                 {
                typeRet=MemoryLoadedProgram;       // This gets claimed later
                break;
             }
        case EfiLoaderData:
        case EfiBootServicesCode:
        case EfiBootServicesData:
             {
                 typeRet=MemoryFirmwareTemporary;
                 break;
             }
        case EfiConventionalMemory:
             {
                typeRet=MemoryFree;
                break;
             }
        case EfiUnusableMemory:
             {
                typeRet=MemoryBad;
                break;
             }
        default:
            //
            // all others are memoryfirmwarepermanent
            //
            break;
    }


    return typeRet;


}



VOID
InsertDescriptor (
    ULONG  BasePage,
    ULONG  NumberOfPages,
    MEMORY_TYPE MemoryType
    )

/*++

Routine Description:

    This routine inserts a descriptor into the correct place in the
    memory descriptor list.
    
    The descriptors come in in EFI_PAGE_SIZE pages and must be
    converted to PAGE_SIZE pages.  This significantly complicates things,
    as we must page align the start of descriptors and hte lengths of the
    descriptors.  
    
    What we do is the following: we store the descriptors in the MDArray with
    EFI_PAGE_SIZE resolution.  When we do an insertion, we check if we can
    coellesce the current entry with the prior entry (we assume our memory map
    is sorted), keeping in mind that we want to ensure our entries are always 
    modulo PAGE_SIZE.
    
    After we've added all of the entries with this routine, we have a post
    processing step that converts all of the (modulo PAGE_SIZE) MDArray entries
    into PAGE_SIZE resolution.

Arguments:

    BasePage      - Base page that the memory starts at.

    NumberOfPages - The number of pages starting at memory block to be inserted.
    
    MemoryType    - An arc memory type describing the memory.

Return Value:

    None.  Updates MDArray global memory array.

--*/

{
    MEMORY_DESCRIPTOR *CurrentEntry, *PriorEntry;
    ULONG NewBasePage, NewNumberOfPages;
    BOOLEAN MustCoellesce = FALSE;
    BOOLEAN ShrinkPrior;

    //
    // Search the spot to insert the new descriptor.
    //
    // We assume that there are no holes in our array.
    //
    CurrentEntry = (MEMORY_DESCRIPTOR *)&MDArray[NumberDescriptors];
    //
    // if this is the first entry, just insert it
    //
    if (NumberDescriptors == 0) {
        
        CurrentEntry->BasePage  = BasePage;
        CurrentEntry->PageCount = NumberOfPages;         
        CurrentEntry->MemoryType = MemoryType;

        //
        // The MDArray is already zeroed out so no need to zero out the next entry.
        //
        NumberDescriptors++;

#if DBG
        wsprintf( DebugBuffer, 
                  L"insert new descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                  NumberDescriptors, MaxDescriptors, BasePage, NumberOfPages, MemoryType);              
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);        
#endif
        return;  
    }

    PriorEntry = (MEMORY_DESCRIPTOR *)&MDArray[NumberDescriptors-1];

    //
    // The last entry had better be empty or the descriptor list is
    // somehow corrupted.
    //
    if (CurrentEntry->PageCount != 0) {
        EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: Inconsistent Descriptor count in InsertDescriptor!\r\n");
        EfiBS->Exit(EfiImageHandle, 0, 0, 0);
    }

    //
    // if the memory type matches the prior entry's memory type, just merge 
    // the two together
    //
    if (PriorEntry->MemoryType == MemoryType) {
        //
        // validate that the array is really sorted correctly
        //
        if (PriorEntry->BasePage + PriorEntry->PageCount != BasePage) {
#if DBG
            wsprintf( DebugBuffer, 
                      L"SuMain: Inconsistent descriptor, PriorEntry->BasePage %x, PriorEntry->PageCount %x, BasePage = %x, type = %x -- insert new descriptor\r\n", 
                      PriorEntry->BasePage,
                      PriorEntry->PageCount, 
                      BasePage, MemoryType);
            EfiST->ConOut->OutputString(EfiST->ConOut,DebugBuffer);
#endif
            CurrentEntry->BasePage  = BasePage;
            CurrentEntry->PageCount = NumberOfPages;
            CurrentEntry->MemoryType = MemoryType;
            NumberDescriptors++;
#if DBG
            wsprintf( DebugBuffer, 
                      L"insert new descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                      NumberDescriptors, MaxDescriptors, BasePage, NumberOfPages, MemoryType);              
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);            
#endif
            return;
        } else {
            PriorEntry->PageCount += NumberOfPages;
#if DBG
            wsprintf( DebugBuffer, 
                      L"merge descriptor #%x of %x, BasePage %x, NumberOfPages %x --> %x, Type (%x)\r\n", 
                      NumberDescriptors, 
                      MaxDescriptors, 
                      PriorEntry->BasePage, 
                      PriorEntry->PageCount - NumberOfPages, 
                      PriorEntry->PageCount, 
                      MemoryType);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);            
#endif
            return;
        }
    }

    //
    // check if the current starting address is module PAGE_SIZE.  If it is,
    // then we know that we must try to coellesce it with the prior entry.
    //
    //
    NewBasePage = BasePage;
    NewNumberOfPages = NumberOfPages;
    if (BasePage % (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) != 0) {
#if DBG
        wsprintf( DebugBuffer, 
                  L"must coellesce because base page %x isn't module PAGE_SIZE (%x mod %x = %x).\r\n", 
                  BasePage,
                  (PAGE_SHIFT - EFI_PAGE_SHIFT),
                  (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)),
                  BasePage % (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
        MustCoellesce = TRUE;
    }

    if (PriorEntry->PageCount % (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) != 0 ) {
#if DBG
        wsprintf( 
            DebugBuffer, 
            L"must coellesce because prior page count %x isn't module PAGE_SIZE (%x mod %x = %x).\r\n", 
            PriorEntry->PageCount,
            (PAGE_SHIFT - EFI_PAGE_SHIFT),
            (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)),
            PriorEntry->PageCount % (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) );
        EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
        MustCoellesce = TRUE;
    }

    if (MustCoellesce) {
        if (PriorEntry->BasePage + PriorEntry->PageCount != BasePage) {
#if DBG
            wsprintf( DebugBuffer, 
                      L"SuMain: Inconsistent descriptor, PriorEntry->BasePage %x, PriorEntry->PageCount %x, BasePage = %x, type = %x -- insert new descriptor\r\n", 
                      PriorEntry->BasePage,
                      PriorEntry->PageCount, 
                      BasePage, MemoryType);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
            MustCoellesce = FALSE;
        }
    }

    if (MustCoellesce) {
        
        switch( MemoryType ) {
            case MemoryFirmwarePermanent:
                //
                // if the current type is permanent, we must steal from the prior entry
                //
                ShrinkPrior = TRUE;
                break;
            case MemoryLoadedProgram:
                if (PriorEntry->MemoryType == MemoryFirmwarePermanent) {
                    ShrinkPrior = FALSE;
                } else {
                    ShrinkPrior = TRUE;
                }
                break;
            case MemoryFirmwareTemporary:
                if (PriorEntry->MemoryType == MemoryFirmwarePermanent ||
                    PriorEntry->MemoryType == MemoryLoadedProgram) {
                    ShrinkPrior = FALSE;
                } else {
                    ShrinkPrior = TRUE;
                }
                break;
            case MemoryFree:
                ShrinkPrior = FALSE;
                break;
            case MemoryBad:
                ShrinkPrior = TRUE;
                break;
            default:
                EfiST->ConOut->OutputString(EfiST->ConOut,
                                    L"SuMain: bad memory type in InsertDescriptor\r\n");
                EfiBS->Exit(EfiImageHandle, 0, 0, 0);
        }

        if (ShrinkPrior) {
            //
            // If the prior entry is small enough, we just convert the whole
            // thing to the new type.
            //
            if (PriorEntry->PageCount <= (PAGE_SHIFT - EFI_PAGE_SHIFT)) {
                PriorEntry->PageCount += NumberOfPages;
                PriorEntry->MemoryType = MemoryType;
                
#if DBG
                wsprintf( DebugBuffer, 
                          L"adjust prior descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                          NumberDescriptors, 
                          MaxDescriptors, 
                          PriorEntry->BasePage, 
                          PriorEntry->PageCount , 
                          PriorEntry->MemoryType);              
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);                
#endif
                return;
            } else {
                //
                // we just steal part of the prior entry.
                //
                PriorEntry->PageCount -= (PAGE_SHIFT - EFI_PAGE_SHIFT);
                NewNumberOfPages += (PAGE_SHIFT - EFI_PAGE_SHIFT);
                NewBasePage -= (PAGE_SHIFT - EFI_PAGE_SHIFT);
                
#if DBG
                wsprintf( DebugBuffer, 
                          L"shrink earlier descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                          NumberDescriptors, 
                          MaxDescriptors, 
                          PriorEntry->BasePage, 
                          PriorEntry->PageCount, 
                          PriorEntry->MemoryType);              
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif

            }
        } else {
            //
            // If the current entry is small enough, we just convert the whole
            // thing to the prior type.
            //
            if (NumberOfPages <= (PAGE_SHIFT - EFI_PAGE_SHIFT)) {
                PriorEntry->PageCount += NumberOfPages;

#if DBG
                wsprintf( DebugBuffer, 
                          L"adjust prior descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                          NumberDescriptors, 
                          MaxDescriptors, 
                          PriorEntry->BasePage, 
                          PriorEntry->PageCount , 
                          PriorEntry->MemoryType);              
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
#endif
                return;
            } else {
                //
                // we just steal part of the new entry, adding it to the last
                // entry
                //
                PriorEntry->PageCount += (PAGE_SHIFT - EFI_PAGE_SHIFT);
                NewNumberOfPages -= (PAGE_SHIFT - EFI_PAGE_SHIFT);
                NewBasePage += (PAGE_SHIFT - EFI_PAGE_SHIFT);
#if DBG
                wsprintf( DebugBuffer, 
                          L"grow earlier descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
                          NumberDescriptors, 
                          MaxDescriptors, 
                          PriorEntry->BasePage, 
                          PriorEntry->PageCount, 
                          PriorEntry->MemoryType);
                EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);                                
#endif
            }
        }        
    }

    //
    // we have now adjusted the prior entry, just insert whatever remains
    //

    CurrentEntry->BasePage  = NewBasePage;
    CurrentEntry->PageCount = NewNumberOfPages;
    CurrentEntry->MemoryType = MemoryType;
    NumberDescriptors++;
#if DBG
    wsprintf( DebugBuffer, 
              L"insert new descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n", 
              NumberDescriptors, 
              MaxDescriptors, 
              CurrentEntry->BasePage, 
              CurrentEntry->PageCount,
              CurrentEntry->MemoryType);              
    EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);    
#endif

    return;
    
}


#if 0

#define DBG_OUT(_X) \
    (EfiST->ConOut->OutputString(EfiST->ConOut, (_X))); \
    while (!BlGetKey());

void DbgOut(PWSTR Str) {
    if (Str)
        DBG_OUT(Str)
}

#endif

#ifdef FORCE_CD_BOOT

void EfiDbg(PWCHAR szStr) {
  DBG_TRACE(szStr);
}

#endif // for FORCE_CD_BOOT



VOID
AdjustMemoryDescriptorSizes(
    VOID
    )
/*++

Routine Description:

    If the EFI_PAGE_SIZE doesn't match PAGE_SIZE, this routine will
    adjust the page sizes to be in PAGE_SIZE resolution.
    
    We assume that the MDArray is already in modulo PAGE_SIZE chunks

Arguments:

    None.

Returns:

    None.  Adjusts MDArray global variable.

--*/
{
    ULONG i;
    MEMORY_DESCRIPTOR *CurrentEntry;
    ULONGLONG Scratch;
    
    for (i = 0; i < NumberDescriptors; i++ ) {
        CurrentEntry = (MEMORY_DESCRIPTOR *)&MDArray[i];

#if 1
        Scratch = (ULONGLONG)CurrentEntry->BasePage << EFI_PAGE_SHIFT;
        Scratch = Scratch >> PAGE_SHIFT;
        CurrentEntry->BasePage = (ULONG)Scratch;
        Scratch = (ULONGLONG)CurrentEntry->PageCount << EFI_PAGE_SHIFT;
        Scratch = Scratch >> PAGE_SHIFT;
        CurrentEntry->PageCount = (ULONG)Scratch;
        if (CurrentEntry->PageCount == 0) {
            wsprintf( DebugBuffer, 
                      L"SuMain: Invalid descriptor size smaller than PAGE_SIZE, BasePage %x, type = %x\r\n", 
                      CurrentEntry->BasePage,
                      CurrentEntry->MemoryType);
            EfiST->ConOut->OutputString( EfiST->ConOut, DebugBuffer);
        }
#else
        CurrentEntry->BasePage = (ULONG)(ULONGLONG)(((ULONGLONG)(CurrentEntry->BasePage << EFI_PAGE_SHIFT)) >> PAGE_SHIFT);
        CurrentEntry->PageCount = (ULONG)((ULONGLONG)(CurrentEntry->PageCount << EFI_PAGE_SHIFT) >> PAGE_SHIFT);
#endif

        sleep(350000);

        /* 
        这一切都是为了对付你，你应该知道 Microsoft.com 和 Google.com 上对全世界的基辅攻击 
    为了安全，一切都是中文加密的 
      基辅集团攻击公司@2009-2024 版权所有
      */       
         }
     }
}